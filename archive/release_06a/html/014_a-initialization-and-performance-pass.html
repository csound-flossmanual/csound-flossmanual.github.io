
<!DOCTYPE HTML>
<html>
 <head>
   

<link type="text/css" href="/site_static/css/booki.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/base/jquery.ui.all.css" rel="Stylesheet" >
<link type="text/css" href="/site_static/js/jquery/themes/smoothness/jquery.ui.all.css" rel="Stylesheet" >
<script type="text/javascript" src="/site_static/js/jquery/jquery-1.4.4.js"></script>
<script type="text/javascript" src="/site_static/js/jquery/ui/jquery-ui-1.8.10.custom.js"></script>
<script type="text/javascript" src="/site_static/js/jquery.json-1.3.js"></script>
<script type="text/javascript" src="/site_static/js/booki.js"></script>
<script src="/site_static/js/messaging.js" type="text/javascript"></script>   
<script type="text/javascript" src="/site_static/js/general.js"></script>
<link href="/site_static/css/jquery.bubblepopup.v2.3.1.css" rel="stylesheet" type="text/css" />
<link type="text/css" href="/site_static/css/jquery-ui_overrides.css" rel="Stylesheet" >
<script src="/site_static/js/jquery.bubblepopup.v2.3.1.min.js" type="text/javascript"></script>

<link rel="SHORTCUT ICON" href="http://write.flossmanuals.net/site_static/images/favicon.ico" type="image/x-icon">


<script type="text/javascript">
  $(function() {
      $.booki.sputnikDispatcherURL = "/_sputnik/";

      $("#dialog-sputnik-error").dialog({
          modal: true,
          autoOpen: false,
          buttons: {
            Ok: function() {
               $(this).dialog('close');
               window.location = '.';
            }
          }
      });
  
      $("FORM.messagefield").messagefield('init', {'view_post': '/messaging/post' });  
  });
</script>


   
 <title>/chapter: A-Initialization-And-Performance-Pass / CSOUND</title>
 <link type="text/css" href="/site_static/css/draft.css" rel="Stylesheet" />

 <link rel="alternate" type="application/rss+xml" title="RSS feed for CSOUND" href="/feeds/rss/book/csound/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for CSOUND" href="/feeds/atom/book/csound/" /> 

 <link rel="alternate" type="application/rss+xml" title="RSS feed for chapter A. INITIALIZATION AND PERFORMANCE PASS" href="/feeds/rss/chapter/csound/csound/" /> 
 <link rel="alternate" type="application/atom+xml" title="Atom feed for chapter A. INITIALIZATION AND PERFORMANCE PASS" href="/feeds/atom/chapter/csound/csound/" /> 
 
 <script type="text/javascript" src="/site_static/js/draft.js"></script>


   <link type="text/css" href="/static/css/_user.css" rel="Stylesheet" >
 </head>
<body>

<div class="topbar"> 
  <div class="logo"><a href="http://write.flossmanuals.net/"></a></div>

  <div class="meta-bar">
    
    <ul>
      <li>
        <a href="/accounts/signin/?redirect=/csound/_draft/_v/1.0/a-initialization-and-performance-pass/">Sign In / Create Account</a>
      </li>
    </ul>
    
    <div style="padding-top: 10px; padding-right: 15px;">
      <br/>
      

<script>
  $(function() {
    var $frm = $("FORM[name=changelang]");
	
    $("A[href=#]", $frm).click(function() {
        var lang = $(this).attr("class").substr(4);
	
        $("INPUT[name=language]", $frm).val(lang);
        $frm.submit();
	
        return false;
    });
  });
 </script>

<form name="changelang" method="POST" action="/accounts/i18n/setlang/?language=en-us">
  <input type="hidden" name="language" value="en-us">
  
    &nbsp;English&nbsp;|
  
  
  
    &nbsp;<a class="langes" href="#">Español</a>&nbsp;|
  

  
    &nbsp;<a class="langfr" href="#">Français</a>&nbsp;|
  
	
  
    &nbsp;<a class="langit" href="#">Italiano</a>&nbsp;|
  
	
  
    &nbsp;<a class="langpt" href="#">Português</a>&nbsp;|
  
	
  
    &nbsp;<a class="langru" href="#">Русский</a>&nbsp;|
  
	
  
    &nbsp;<a class="langsq" href="#">Shqip</a>
  	
</form>

    </div>
    
    
  </div><!-- End of .meta-bar -->
</div><!-- End top bar -->

<div class="menubar shadow">
  
  
  <div class="navbox">
    <ul>
      <li><a href="/list-books/">Books</a></li>
      <li><a href="/list-groups/">Groups</a></li>
      <li><a href="/list-people/">People</a></li>
    </ul>      
  </div><!-- End of .navbox -->       
</div>

<div class="content-container">
  <div class="content shadow">
    <!-- Content box and the drop shadow-->
    

<h2>CSOUND</h2>
<div class="padded">
 <div id="bookmenu" style="background: url(/site_static/images/draft_bg.png) repeat !important;"> 
  <ul>
   
    
      <li><b>INTRODUCTION</b></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/preface/">PREFACE</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/how-to-use-this-manual/">HOW TO USE THIS MANUAL</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/on-this-release/">ON THIS RELEASE</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/credits/">CREDITS</a></li>
    
   
    
      <li><b>01 BASICS</b></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/a-digital-audio/">A. DIGITAL AUDIO</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/b-pitch-and-frequency/">B. PITCH AND FREQUENCY</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/c-intensities/">C. INTENSITIES</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/d-random/">D. RANDOM</a></li>
    
   
    
      <li><b>02 QUICK START</b></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/a-make-csound-run/">A. MAKE CSOUND RUN</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/b-csound-syntax/">B. CSOUND SYNTAX</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/c-configuring-midi/">C. CONFIGURING MIDI</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/d-live-audio/">D. LIVE AUDIO</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/e-rendering-to-file/">E. RENDERING TO FILE</a></li>
    
   
    
      <li><b>03 CSOUND LANGUAGE</b></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/a-initialization-and-performance-pass/">A. INITIALIZATION AND PERFORMANCE PASS</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/b-local-and-global-variables/">B. LOCAL AND GLOBAL VARIABLES</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/c-control-structures/">C. CONTROL STRUCTURES</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/d-function-tables/">D. FUNCTION TABLES</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/e-arrays/">E. ARRAYS</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/f-live-events/">F. LIVE EVENTS</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/g-user-defined-opcodes/">G. USER DEFINED OPCODES</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/h-macros/">H. MACROS</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/i-functional-syntax/">I. FUNCTIONAL SYNTAX</a></li>
    
   
    
      <li><b>04 SOUND SYNTHESIS</b></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/a-additive-synthesis/">A. ADDITIVE SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/b-subtractive-synthesis/">B. SUBTRACTIVE SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/c-amplitude-and-ring-modulation/">C. AMPLITUDE AND RING MODULATION</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/d-frequency-modulation/">D. FREQUENCY MODULATION</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/e-waveshaping/">E. WAVESHAPING</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/f-granular-synthesis/">F. GRANULAR SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/g-physical-modelling/">G. PHYSICAL MODELLING</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/h-scanned-synthesis/">H. SCANNED SYNTHESIS</a></li>
    
   
    
      <li><b>05 SOUND MODIFICATION</b></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/a-envelopes/">A. ENVELOPES</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/b-panning-and-spatialization/">B. PANNING AND SPATIALIZATION</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/c-filters/">C. FILTERS</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/d-delay-and-feedback/">D. DELAY AND FEEDBACK</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/e-reverberation/">E. REVERBERATION</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/f-am-rm-waveshaping/">F. AM / RM / WAVESHAPING</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/g-granular-synthesis/">G. GRANULAR SYNTHESIS</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/h-convolution/">H. CONVOLUTION</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/i-fourier-analysis-spectral-processing/">I. FOURIER ANALYSIS / SPECTRAL PROCESSING</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/k-ats-resynthesis/">K. ATS RESYNTHESIS</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/l-amplitude-and-pitch-tracking/">L. AMPLITUDE AND PITCH TRACKING</a></li>
    
   
    
      <li><b>06 SAMPLES</b></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/a-record-and-play-soundfiles/">A. RECORD AND PLAY SOUNDFILES</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/b-record-and-play-buffers/">B. RECORD AND PLAY BUFFERS</a></li>
    
   
    
      <li><b>07 MIDI</b></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/a-receiving-events-by-midiin/">A. RECEIVING EVENTS BY MIDIIN</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/b-triggering-instrument-instances/">B. TRIGGERING INSTRUMENT INSTANCES</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/c-working-with-controllers/">C. WORKING WITH CONTROLLERS</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/d-reading-midi-files/">D. READING MIDI FILES</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/e-midi-output/">E. MIDI OUTPUT</a></li>
    
   
    
      <li><b>08 OTHER COMMUNICATION</b></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/a-open-sound-control/">A. OPEN SOUND CONTROL</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/b-csound-and-arduino/">B. CSOUND AND ARDUINO</a></li>
    
   
    
      <li><b>09 CSOUND IN OTHER APPLICATIONS</b></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/a-csound-in-pd/">A. CSOUND IN PD</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/b-csound-in-maxmsp/">B. CSOUND IN MAXMSP</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/c-csound-in-ableton-live/">C. CSOUND IN ABLETON LIVE</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/d-csound-as-a-vst-plugin/">D. CSOUND AS A VST PLUGIN</a></li>
    
   
    
      <li><b>10 CSOUND FRONTENDS</b></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/csoundqt/">CSOUNDQT</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/cabbage/">CABBAGE</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/blue/">BLUE</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/winxound/">WINXOUND</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/csound-via-terminal/">CSOUND VIA TERMINAL</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/web-based-csound/">WEB BASED CSOUND</a></li>
    
   
    
      <li><b>11 CSOUND UTILITIES</b></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/csound-utilities/">CSOUND UTILITIES</a></li>
    
   
    
      <li><b>12 CSOUND AND OTHER PROGRAMMING LANGUAGES</b></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/a-the-csound-api/">A. THE CSOUND API</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/b-python-inside-csound/">B. PYTHON INSIDE CSOUND</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/c-python-in-csoundqt/">C. PYTHON IN CSOUNDQT</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/d-lua-in-csound/">D. LUA IN CSOUND</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/e-csound-in-ios/">E. CSOUND IN iOS</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/f-csound-on-android/">F. CSOUND ON ANDROID</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/g-csound-and-haskell/">G. CSOUND AND HASKELL</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/h-csound-and-html/">H. CSOUND AND HTML</a></li>
    
   
    
      <li><b>13 EXTENDING CSOUND</b></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/extending-csound/">EXTENDING CSOUND</a></li>
    
   
    
      <li><b>OPCODE GUIDE</b></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/overview/">OVERVIEW</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/signal-processing-i/">SIGNAL PROCESSING I</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/signal-processing-ii/">SIGNAL PROCESSING II</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/data/">DATA</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/realtime-interaction/">REALTIME INTERACTION</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/instrument-control/">INSTRUMENT CONTROL</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/maths-pythonsystem-plugins/">MATHS, PYTHON/SYSTEM, PLUGINS</a></li>
    
   
    
      <li><b>APPENDIX</b></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/methods-of-writing-csound-scores/">METHODS OF WRITING CSOUND SCORES</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/glossary/">GLOSSARY</a></li>
    
   
    
      <li><a href="/csound/_draft/_v/1.0/links/">LINKS</a></li>
    
   
  </ul>
 </div>
 <div id="bookcontent"   style="background: url(/site_static/images/draft_bg.png) repeat !important;">
   

  <html><head><title>Csound: InitAndPerfPass</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><br></head><body><h1>INITIALIZATION AND PERFORMANCE PASS
</h1>
<p>Not only for beginners, but also for experienced Csound users, many problems result from the misunderstanding of the so-called i-rate and k-rate. You want Csound to do something just once, but Csound does it continuously. You want Csound to do something continuously, but Csound does it just once. If you experience such a case, you will most probably have confused i- and k-rate-variables.
</p>
<p>The concept behind this is actually not complicated. But it is something which is more implicitly mentioned when we think of a program flow, whereas Csound wants to know it explicitely. So we tend to forget it when we use Csound, and we do not notice that we ordered a stone to become a wave, and a wave to become a stone. This chapter tries to explicate very carefully the difference between stones and waves, and how you can profit from them, after you understood and accepted both qualities.
</p>
<p>
</p>
<h2>The Init Pass
</h2>
<p>Whenever a Csound instrument is called, all variables are set to initial values. This is called the initialization pass.
</p>
<p>There are certain variables, which stay in the state in which they have been put by the init-pass. These variables start with an <strong>i</strong> if they are local (= only considered inside an instrument), or with a <strong>gi</strong> if they are global (= considered overall in the orchestra). This is a simple example:
</p>
<p>   <em><strong>EXAMPLE 03A01_Init-pass.csd</strong></em>
  <br></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;

giGlobal   =          1/2

instr 1
iLocal     =          1/4
           print      giGlobal, iLocal
endin

instr 2
iLocal     =          1/5
           print      giGlobal, iLocal
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 0
i 2 0 0
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>The output should include these lines:
  <br><font face="courier new,courier,monospace" size="2">SECTION 1:
  <br>new alloc for instr 1:
  <br>instr 1:  giGlobal = 0.500  iLocal = 0.250
  <br>new alloc for instr 2:
  <br>instr 2:  giGlobal = 0.500  iLocal = 0.200 </font>
</p>
<p>As you see, the local variables <em>iLocal</em> do have different meanings in the context of their instrument, whereas <em>giGlobal</em> is known everywhere and in the same way. It is also worth mentioning that the performance time of the instruments (p3) is zero. This makes sense, as the instruments are called, but only the init-pass is performed.<span class="InsertNoteMarker" id="InsertNoteID_6_marker7"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_6">1</a></sup></span>
</p>
<h2>The Performance Pass
</h2>
<p>After having assigned initial values to all variables, Csound starts the actual performance. As music is a variation of values in time,<span class="InsertNoteMarker" id="InsertNoteID_8_marker9"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_8">2</a></sup></span>  audio signals are producing values which vary in time. In all digital audio, the time unit is given by the sample rate, and one sample is the smallest possible time atom. For a sample rate of 44100 Hz,<span class="InsertNoteMarker" id="InsertNoteID_10_marker11"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_10">3</a></sup></span>  one sample comes up to the duration of 1/44100 = 0.0000227 seconds.
</p>
<p>So, performance for an audio application means basically: calculate all the samples which are finally being written to the output. You can imagine this as the cooperation of a clock and a calculator. For each sample, the clock ticks, and for each tick, the next sample is calculated.
</p>
<p>Most audio applications do not perform this calculation sample by sample. It is much more efficient to collect some amount of samples in a "block" or "vector", and calculate them all together. This means in fact, to introduce another internal clock in your application; a clock which ticks less frequently than the sample clock. For instance, if (always assumed your sample rate is 44100 Hz) your block size consists of 10 samples, your internal calculation time clock ticks every 1/4410 (0.000227) seconds. If your block size consists of 441 samples, the clock ticks every 1/100 (0.01) seconds.
</p>
<p>The following illustration shows an example for a block size of 10 samples. The samples are shown at the bottom line. Above are the control ticks, one for each ten samples. The top two lines show the times for both clocks in seconds. In the upmost line you see that the first control cycle has been finished at 0.000227 seconds, the second one at 0.000454 seconds, and so on.<span class="InsertNoteMarker" id="InsertNoteID_28_marker29"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_28">4</a></sup></span> 
  <br><br><img src="static/03A_sr_kr_time3.png" height="204" width="600"><br><br>The rate (frequency) of these ticks is called the control rate in Csound. By historical reason,<span class="InsertNoteMarker" id="InsertNoteID_12_marker13"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_12">5</a></sup></span>  it is called "kontrol rate" instead of control rate, and abbreviated as "kr" instead of cr. Each of the calculation cycles is called a "k-cycle". The block size or vector size is given by the <em>ksmps</em> parameter, which means: how many samples (smps) are collected for one k-cycle.<span class="InsertNoteMarker" id="InsertNoteID_14_marker15"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_14">6</a></sup></span>
</p>
<p>Let us see some code examples to illustrate these basic contexts.
  <br></p>
<h3>Implicit Incrementation
  <br></h3>
<p>   <em><strong>EXAMPLE 03A02_Perf-pass_incr.csd</strong></em>
  <br></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 4410

instr 1
kCount    init      0; set kcount to 0 first
kCount    =         kCount + 1; increase at each k-pass
          printk    0, kCount; print the value
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>Your output should contain the lines:
  <br><font face="courier new,courier,monospace" size="2">i   1 time     0.10000:     1.00000
  <br>i   1 time     0.20000:     2.00000
  <br>i   1 time     0.30000:     3.00000
  <br>i   1 time     0.40000:     4.00000
  <br>i   1 time     0.50000:     5.00000
  <br>i   1 time     0.60000:     6.00000
  <br>i   1 time     0.70000:     7.00000
  <br>i   1 time     0.80000:     8.00000
  <br>i   1 time     0.90000:     9.00000
  <br>i   1 time     1.00000:    10.00000 </font>
</p>
<p>A counter (kCount) is set here to zero as initial value. Then, in each control cycle, the counter is increased by one. What we see here, is the typical behaviour of a loop. The loop has not been set explicitely, but works implicitely because of the continuous recalculation of all k-variables. So we can also speak about the k-cycles as an implicit (and time-triggered) k-loop.<span class="InsertNoteMarker" id="InsertNoteID_16_marker17"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_16">7</a></sup></span>  Try changing the ksmps value from 4410 to 8820 and to 2205 and observe the difference.
</p>
<p>The next example reads the incrementation of <em>kCount</em> as rising frequency. The first instrument, called Rise, sets the k-rate frequency <em>kFreq</em> to the initial value of 100 Hz, and then adds 10 Hz in every new k-cycle. As ksmps=441, one k-cycle takes 1/100 second to perform. So in 3 seconds, the frequency rises from 100 to 3100 Hz. At the last k-cycle, the final frequency value is printed out.<span class="InsertNoteMarker" id="InsertNoteID_18_marker19"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_18">8</a></sup></span>  - The second instrument, Partials, increments the counter by one for each k-cycle, but only sets this as new frequency for every 100 steps. So the frequency stays at 100 Hz for one second, then at 200 Hz for one second, and so on. As the resulting frequencies are in the ratio 1 : 2 : 3 ..., we hear partials based on a 100 Hz fundamental, from the first partial up to the 31st. The opcode printk2 prints out the frequency value whenever it has changed.
  <br></p>
<p>   <em><strong>EXAMPLE 03A03_Perf-pass_incr_listen.csd</strong></em>
  <br></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 441
0dbfs = 1
nchnls = 2

;build a table containing a sine wave
giSine     ftgen      0, 0, 2^10, 10, 1

instr Rise
kFreq      init       100
aSine      poscil     .2, kFreq, giSine
           outs       aSine, aSine
;increment frequency by 10 Hz for each k-cycle
kFreq      =          kFreq + 10
;print out the frequency for the last k-cycle
kLast      release
 if kLast == 1 then
           printk     0, kFreq
 endif
endin

instr Partials
;initialize kCount
kCount     init       100
;get new frequency if kCount equals 100, 200, ...
 if kCount % 100 == 0 then
kFreq      =          kCount
 endif
aSine      poscil     .2, kFreq, giSine
           outs       aSine, aSine
;increment kCount
kCount     =          kCount + 1
;print out kFreq whenever it has changed
           printk2    kFreq
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i "Rise" 0 3
i "Partials" 4 31
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
<p>;example by joachim heintz
</p></pre>
<h3>Init versus Equals
  <br></h3>
<p>A frequently occuring error is that instead of setting the k-variable as <em>kCount init 0</em>, it is set as <em>kCount = 0</em>. The meaning of both statements has one significant difference. <em>kCount init 0</em> sets the value for kCount to zero only in the init pass, without affecting it during the performance pass. kCount = 1 sets the value for kCount to zero again and again, in each performance cycle. So the increment always starts from the same point, and nothing really happens:
  <br></p>
<p>   <em><strong>EXAMPLE 03A04_Perf-pass_no_incr.csd</strong></em>
  <br></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 4410

instr 1
kcount    =         0; sets kcount to 0 at each k-cycle
kcount    =         kcount + 1; does not really increase ...
          printk    0, kcount; print the value
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>Outputs:
  <br><font face="courier new,courier,monospace" size="2"> i   1 time     0.10000:     1.00000
  <br> i   1 time     0.20000:     1.00000
  <br> i   1 time     0.30000:     1.00000
  <br> i   1 time     0.40000:     1.00000
  <br> i   1 time     0.50000:     1.00000
  <br> i   1 time     0.60000:     1.00000
  <br> i   1 time     0.70000:     1.00000
  <br> i   1 time     0.80000:     1.00000
  <br> i   1 time     0.90000:     1.00000
  <br> i   1 time     1.00000:     1.00000 </font>
</p>
<h3>A Look at the Audio Vector
  <br></h3>
<p>There are different opcodes to print out k-variables.<span class="InsertNoteMarker" id="InsertNoteID_20_marker21"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_20">9</a></sup></span> There is no opcode in Csound to print out the audio vector directly, but you can use the <em>vaget</em> opcode to see what is happening inside one control cycle with the audio samples.
  <br></p>
<p>   <em><strong>EXAMPLE 03A05_Audio_vector.csd</strong></em>
  <br></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 5
0dbfs = 1

instr 1
aSine      oscils     1, 2205, 0
kVec1      vaget      0, aSine
kVec2      vaget      1, aSine
kVec3      vaget      2, aSine
kVec4      vaget      3, aSine
kVec5      vaget      4, aSine
           printks    "kVec1 = % f, kVec2 = % f, kVec3 = % f, kVec4 = % f, kVec5 = % f\n",\
                      0, kVec1, kVec2, kVec3, kVec4, kVec5
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 [1/2205]
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>The output shows these lines:
  <br><font face="courier new,courier,monospace" size="2">kVec1 =  0.000000, kVec2 =  0.309017, kVec3 =  0.587785, kVec4 =  0.809017, kVec5 =  0.951057
  <br>kVec1 =  1.000000, kVec2 =  0.951057, kVec3 =  0.809017, kVec4 =  0.587785, kVec5 =  0.309017
  <br>kVec1 = -0.000000, kVec2 = -0.309017, kVec3 = -0.587785, kVec4 = -0.809017, kVec5 = -0.951057
  <br>kVec1 = -1.000000, kVec2 = -0.951057, kVec3 = -0.809017, kVec4 = -0.587785, kVec5 = -0.309017 </font>
</p>
<p>In this example, the number of audio samples in one k-cycle is set to five by the statement <em>ksmps=5</em>. The first argument to vaget specifies which sample of the block you get. For instance,
  <br></p>
<pre>kVec1      vaget      0, aSine</pre>
<p>gets the first value of the audio vector and writes it into the variable kVec1. For a frequency of 2205 Hz at a sample rate of 44100 Hz, you need 20 samples to write one complete cycle of the sine. So we call the instrument for 1/2205 seconds, and we get 4 k-cycles. The printout shows exactly one period of the sine wave.
</p>
<h3>A Summarizing Example
  <br></h3>
<p>After having put so much attention to the different single aspects of initialization, performance and audio vectors, the next example tries to summarize and illustrate all the aspects in their practical mixture.
</p>
<p>
</p>
<p>   <em><strong>EXAMPLE 03A06_Init_perf_audio.csd</strong></em> 
  <br></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 441
nchnls = 2
0dbfs = 1
instr 1
iAmp      =       p4 ;amplitude taken from the 4th parameter of the score line
iFreq     =       p5 ;frequency taken from the 5th parameter
; --- move from 0 to 1 in the duration of this instrument call (p3)
kPan      line      0, p3, 1
aNote     oscils  iAmp, iFreq, 0 ;create an audio signal
aL, aR    pan2    aNote, kPan ;let the signal move from left to right
          outs    aL, aR ;write it to the output
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3 0.2 443
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>As ksmps=441, each control cycle is 0.01 seconds long (441/44100). So this happens when the instrument call is performed:
</p>
<p><img title="InitAndPerfPass3" alt="InitAndPerfPass3" src="/csound/_edit/static/Csound-Picts-03_CsLanguage-InitAndPerfPass3-en.png" height="326" width="600"> 
  <br></p>
<p> 
</p>
<h2>Accessing the Initialization Value of a k-Variable
</h2>
<p>It has been said that the init pass sets initial values to all variables. It must be emphasized that this indeed concerns all variables, not only the i-variables. It is only the matter that i-variables are not affected by anything which happens later, in the performance. But also k- and a-variables get their initial values.
</p>
<p>As we saw, the init opcode is used to set initial values for k- or a-variables explicitely. On the other hand, you can get the initial value of a k-variable which has not been set explicitely, by the i() facility. This is a simple example:
  <br></p>
<p>
</p>
<p>   <em><strong>EXAMPLE 03A07_Init-values_of_k-variables.csd</strong></em> 
  <br></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
instr 1
gkLine line 0, p3, 1
endin
instr 2
iInstr2LineValue = i(gkLine)
print iInstr2LineValue
endin
instr 3
iInstr3LineValue = i(gkLine)
print iInstr3LineValue
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 5
i 2 2 0
i 3 4 0
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz</pre>
<p>Outputs:
  <br><font face="courier new,courier,monospace" size="2">new alloc for instr 1:
  <br>B  0.000 ..  2.000 T  2.000 TT  2.000 M:      0.0
  <br>new alloc for instr 2:
  <br>instr 2:  iInstr2LineValue = 0.400
  <br>B  2.000 ..  4.000 T  4.000 TT  4.000 M:      0.0
  <br>new alloc for instr 3:
  <br>instr 3:  iInstr3LineValue = 0.800
  <br>B  4.000 ..  5.000 T  5.000 TT  5.000 M:      0.0 </font>
</p>
<p>Instrument 1 produces a rising k-signal, starting at zero and ending at one, over a time of five seconds. The values of this line rise are written to the global variable <em>gkLine</em>. After two seconds, instrument 2 is called, and examines the value of <em>gkLine</em> at its init-pass via <em><strong>i</strong>(gkLine)</em>. The value at this time (0.4), is printed out at init-time as <em>iInstr2LineValue</em>. The same happens for instrument 3, which prints out <em>iInstr3LineValue = 0.800</em>, as it has been started at 4 seconds.
</p>
<p>The i() feature is particularily useful if you need to examine the value of any control signal from a widget or from midi, at the time when an instrument starts.
</p>
<h2>k-Values and Initialization in Multiple Triggered Instruments
</h2>
<p>What happens on a k-variable if an instrument is called multiple times? What is the initialization value of this variable on the first call, and on the subsequent calls?
</p>
<p>If this variable is not set explicitely, the init value in the first call of an instrument is zero, as usual. But, for the next calls, the k-variable is initialized to the value which was left when the previous instance of the same instrument turned off.
</p>
<p>The following example shows this behaviour.  Instrument "Call" simply calls the instrument "Called" once a second, and sends the number of the call to it.  Instrument "Called" generates the variable kRndVal by a random generator, and reports both:
  <br>- the value of kRndVal at initialization, and
  <br>- the value of kRndVal at performance time, i.e. the first control cycle.
  <br>(After the first k-cycle, the instrument is turned off immediately.)
</p>
<p>   <em><strong>EXAMPLE 03A08_k-inits_in_multiple_calls_1.csd</strong></em>
</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-nm0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
ksmps = 32

 instr Call
kNumCall init 1
kTrig metro 1
if kTrig == 1 then
  event "i", "Called", 0, 1, kNumCall
  kNumCall += 1
endif
 endin

 instr Called
iNumCall = p4
kRndVal random 0, 10
prints "Initialization value of kRnd in call %d = %.3f\n", iNumCall, i(kRndVal)
printks "  New random value of kRnd generated in call %d = %.3f\n", 0, iNumCall, kRndVal
turnoff
 endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i "Call" 0 3
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>The output should show this:
</p>
<p><font face="courier new,courier,monospace" size="2">Initialization value of kRnd in call 1 = 0.000
  <br>  New random value of kRnd generated in call 1 = 8.829
  <br>Initialization value of kRnd in call 2 = 8.829
  <br>  New random value of kRnd generated in call 2 = 2.913
  <br>Initialization value of kRnd in call 3 = 2.913
  <br>  New random value of kRnd generated in call 3 = 9.257 </font>
  <br></p>
<p>The printout shows what was stated before: If there is no previous value of a k-variable, this variable is initialized to zero.  If there is a previous value, it serves as initialization value.
</p>
<p>But is this init-value of a k-variable of any relevance?  Actually, we choose a k-value because we want to use it at performance-time, not at init-time.  —  Well, the problem is that Csound *will* perform the init-pass for all k- (and a-) variables, unless you prevent it from doing this explicitely.  And if you, for example, generate an array index in the previous instance of the same instrument, which is out of range at initialization, Csound will report an error, or even crash:
</p>
<p>   <em><strong>EXAMPLE 03A09_Init_no_incr.csd</strong></em> 
</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-nm0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
ksmps = 32

gkArray[] fillarray 1, 2, 3, 5, 8

instr Call
kNumCall init 1
kTrig metro 1
if kTrig == 1 then
  event "i", "Called", 0, 1, kNumCall
  kNumCall += 1
endif
endin

instr Called
  ;get the number of the instrument instance
iNumCall = p4
  ;set the start index for the while-loop
kIndex = 0
  ;get the init value of kIndex
prints "Initialization value of kIndx in call %d = %d\n", iNumCall, i(kIndex)
  ;perform the while-loop until kIndex equals five
while kIndex &lt; lenarray(gkArray) do
  printf "Index %d of gkArray has value %d\n", kIndex+1, kIndex, gkArray[kIndex]
  kIndex += 1
od
  ;last value of kIndex is 5 because of increment
printks "  Last value of kIndex in call %d = %d\n", 0, iNumCall, kIndex
  ;turn this instance off after first k-cycle
turnoff
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i "Call" 0 1 ;change performance time to 2 to get an error!
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>When you change the performance time to 2 instead of 1, you will get an error, because the array will be asked for index=5.  (But, as the length of this array is 5, the last index is 4.)  This will be the output in this case:
</p>
<p> <font size="2"><font face="courier new,courier,monospace">Initialization value of kIndx in call 1 = 0
  <br>Index 0 of gkArray has value 1
  <br>Index 1 of gkArray has value 2
  <br>Index 2 of gkArray has value 3
  <br>Index 3 of gkArray has value 5
  <br>Index 4 of gkArray has value 8
  <br>  Last value of kIndex in call 1 = 5
  <br>Initialization value of kIndx in call 2 = 5
  <br>PERF ERROR in instr 2: Array index 5 out of range (0,4) for dimension 1
  <br>   note aborted
  <br></font></font>
</p>
<p>The problem is that the expression gkArray[kIndex] is performed *at init-time*.  And, that the expression kIndex=0 has no effect at all to the value of kIndex *at init-time*.  If we want to be sure that kIndex is zero also at init-time, we must write this explicitely by
</p>
<pre>kIndex init 0
</pre>
<p>Note that this is *exactly* the same for User-Defined Opcodes!  If you call a UDO twice, it will have the current value of a k-Variable of the first call as init-value of the second call, unless you initialize the k-variable explicitely by an init statement.
</p>
<p>The final example shows both possibilities, using explicit initialization or not, and the resulting effect.
</p>
<p>   <em><strong>EXAMPLE 03A10_k-inits_in_multiple_calls_3.csd</strong></em>
  <br></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-nm0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
ksmps = 32

instr without_init
prints "instr without_init, call %d:\n", p4
kVal = 1
prints "  Value of kVal at initialization = %d\n", i(kVal)
printks "  Value of kVal at first k-cycle = %d\n", 0, kVal
kVal = 2
turnoff
endin

instr with_init
prints "instr with_init, call %d:\n", p4
kVal init 1
kVal = 1
prints "  Value of kVal at initialization = %d\n", i(kVal)
printks "  Value of kVal at first k-cycle = %d\n", 0, kVal
kVal = 2
turnoff
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i "without_init" 0 .1 1
i "without_init" + .1 2
i "with_init" 1 .1 1
i "with_init" + .1 2
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>This is the output:
</p>
<p> <font size="2"><font face="courier new,courier,monospace">instr without_init, call 1:
  <br>  Value of kVal at initialization = 0
  <br>  Value of kVal at first k-cycle = 1
  <br>instr without_init, call 2:
  <br>  Value of kVal at initialization = 2
  <br>  Value of kVal at first k-cycle = 1
  <br>instr with_init, call 1:
  <br>  Value of kVal at initialization = 1
  <br>  Value of kVal at first k-cycle = 1
  <br>instr with_init, call 2:
  <br>  Value of kVal at initialization = 1
  <br>  Value of kVal at first k-cycle = 1</font></font>
  <br></p>
<p>
</p>
<h2>Reinitialization
</h2>
<p>As we saw above, an i-value is not affected by the performance loop. So you cannot expect this to work as an incrementation:
  <br></p>
<p>
</p>
<p>   <em><strong>EXAMPLE 03A11_Init_no_incr.csd</strong></em> 
  <br></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 4410

instr 1
iCount    init      0          ;set iCount to 0 first
iCount    =         iCount + 1 ;increase
          print     iCount     ;print the value
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz</pre>
<p>The output is nothing but:
  <br><font face="courier new,courier,monospace" size="2">instr 1:  iCount = 1.000 </font>
</p>
<p>But you can advise Csound to repeat the initialization of an i-variable. This is done with the <em>reinit</em> opcode. You must mark a section by a label (any name followed by a colon). Then the reinit statement will cause the i-variable to refresh. Use rireturn to end the reinit section.
  <br></p>
<p>
</p>
<p>   <em><strong>EXAMPLE 03A12_Re-init.csd</strong></em> 
  <br></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 4410

instr 1
iCount    init      0          ; set icount to 0 first
          reinit    new        ; reinit the section each k-pass
new:
iCount    =         iCount + 1 ; increase
          print     iCount     ; print the value
          rireturn
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz</pre>
<p>Outputs:
  <br><font face="courier new,courier,monospace" size="2">instr 1:  iCount = 1.000
  <br>instr 1:  iCount = 2.000
  <br>instr 1:  iCount = 3.000
  <br>instr 1:  iCount = 4.000
  <br>instr 1:  iCount = 5.000
  <br>instr 1:  iCount = 6.000
  <br>instr 1:  iCount = 7.000
  <br>instr 1:  iCount = 8.000
  <br>instr 1:  iCount = 9.000
  <br>instr 1:  iCount = 10.000
  <br>instr 1:  iCount = 11.000 </font>
  <br><br>What happens here more in detail, is the following. In the actual init-pass, <em>iCount</em> is set to zero via <em>iCount init 0</em>. Still in this init-pass, it is incremented by one (iCount = iCount+1) and the value is printed out as <em>iCount = 1.000</em>. Now starts the first performance pass. The statement <em>reinit new</em> advices Csound to initialise again the section labeled as "new". So the statement <em>iCount = iCount + 1</em> is executed again. As the current value of <em>iCount</em> at this time is 1, the result is 2. So the printout at this first performance pass is<em> iCount = 2.000</em>. The same happens in the next nine performance cycles, so the final count is 11.
</p>
<h2>Order Of Calculation
</h2>
<p>In this context, it can be very important to observe the order in which the instruments of a Csound orchestra are evaluated. This order is determined by the instrument numbers. So, if you want to use during the same performance pass a value in instrument 10 which is generated by another instrument, you must not give this instrument the number 11 or higher. In the following example, first instrument 10 uses a value of instrument 1, then a value of instrument 100.
  <br></p>
<p>
</p>
<p>   <em><strong>EXAMPLE 03A13_Order_of_calc.csd</strong></em> 
  <br></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 4410

instr 1
gkcount   init      0 ;set gkcount to 0 first
gkcount   =         gkcount + 1 ;increase
endin

instr 10
          printk    0, gkcount ;print the value
endin

instr 100
gkcount   init      0 ;set gkcount to 0 first
gkcount   =         gkcount + 1 ;increase
endin


&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;first i1 and i10
i 1 0 1
i 10 0 1
;then i100 and i10
i 100 1 1
i 10 1 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;Example by Joachim Heintz</pre>
<p>The output shows the difference:
  <br><font face="courier new,courier,monospace" size="2">new alloc for instr 1:
  <br>new alloc for instr 10:
  <br> i  10 time     0.10000:     1.00000
  <br> i  10 time     0.20000:     2.00000
  <br> i  10 time     0.30000:     3.00000
  <br> i  10 time     0.40000:     4.00000
  <br> i  10 time     0.50000:     5.00000
  <br> i  10 time     0.60000:     6.00000
  <br> i  10 time     0.70000:     7.00000
  <br> i  10 time     0.80000:     8.00000
  <br> i  10 time     0.90000:     9.00000
  <br> i  10 time     1.00000:    10.00000
  <br>B  0.000 ..  1.000 T  1.000 TT  1.000 M:      0.0
  <br>new alloc for instr 100:
  <br> i  10 time     1.10000:     0.00000
  <br> i  10 time     1.20000:     1.00000
  <br> i  10 time     1.30000:     2.00000</font><font face="courier new,courier,monospace" size="2"><font face="courier new,courier,monospace" size="2">
  <br> i  10 time     1.40000:     3.00000 </font>
  <br> i  10 time     1.50000:     4.00000
  <br> i  10 time     1.60000:     5.00000
  <br> i  10 time     1.70000:     6.00000
  <br> i  10 time     1.80000:     7.00000
  <br> i  10 time     1.90000:     8.00000
  <br> i  10 time     2.00000:     9.00000
  <br>B  1.000 ..  2.000 T  2.000 TT  2.000 M:      0.0 </font>
</p>
<p>Instrument 10 can use the values which instrument 1 has produced in the same control cycle, but it can only refer to values of instrument 100 which are produced in the previous control cycle. By this reason, the printout shows values which are one less in the latter case.
</p>
<h2>Named Instruments
</h2>
<p>It has been said in chapter 02B (Quick Start) that instead of a number you can also use a name for an instrument. This is mostly preferable, because you can give meaningful names, leading to a better readable code. But what about the order of calculation in named instruments?
</p>
<p>The answer is simple: Csound calculates them in the same order as they are written in the orchestra. So if your instrument collection is like this ...
  <br></p>
<p>
</p>
<p>   <em><strong>EXAMPLE 03A14_Order_of_calc_named.csd</strong></em> 
  <br></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-nd
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;

instr Grain_machine
prints " Grain_machine\n"
endin

instr Fantastic_FM
prints "  Fantastic_FM\n"
endin

instr Random_Filter
prints "   Random_Filter\n"
endin

instr Final_Reverb
prints "    Final_Reverb\n"
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i "Final_Reverb" 0 1
i "Random_Filter" 0 1
i "Grain_machine" 0 1
i "Fantastic_FM" 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz</pre>
<p>... you can count on this output:
  <br><font face="courier new,courier,monospace" size="2">new alloc for instr Grain_machine:
  <br> Grain_machine
  <br>new alloc for instr Fantastic_FM:
  <br>  Fantastic_FM
  <br>new alloc for instr Random_Filter:
  <br>   Random_Filter
  <br>new alloc for instr Final_Reverb:
  <br>    Final_Reverb </font>
</p>
<p>Note that the score has not the same order. But internally, Csound transforms all names to numbers, in the order they are written from top to bottom. The numbers are reported on the top of Csound's output:<span class="InsertNoteMarker" id="InsertNoteID_22_marker23"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_22">10</a></sup></span> 
  <br><font face="courier new,courier,monospace" size="2">instr Grain_machine uses instrument number 1
  <br>instr Fantastic_FM uses instrument number 2
  <br>instr Random_Filter uses instrument number 3
  <br>instr Final_Reverb uses instrument number 4 </font>
</p>
<h2>About "i-time" And "k-rate" Opcodes
</h2>
<p>It is often confusing for the beginner that there are some opcodes which only work at "i-time" or "i-rate", and others which only work at "k-rate" or "k-time". For instance, if the user wants to print the value of any variable, (s)he thinks: "OK - print it out." But Csound replies: "Please, tell me first if you want to print an i- or a k-variable".<span class="InsertNoteMarker" id="InsertNoteID_24_marker25"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_24">11</a></sup></span>
</p>
<p>The <a href="http://csounds.com/manual/html/print.html">print</a> opcode just prints variables which are updated at each initialization pass ("i-time" or "i-rate"). If you want to print a variable which is updated at each control cycle ("k-rate" or "k-time"), you need its counterpart <a href="http://csounds.com/manual/html/printk.html">printk</a>. (As the performance pass is usually updated some thousands times per second, you have an additional parameter in printk, telling Csound how often you want to print out the k-values.)
</p>
<p>So, some opcodes are just for i-rate variables, like <a href="http://csounds.com/manual/html/filelen.html">filelen</a> or <a href="http://csounds.com/manual/html/ftgen.html">ftgen</a>. Others are just for k-rate variables like <a href="http://csounds.com/manual/html/metro.html">metro</a> or <a href="http://csounds.com/manual/html/max_k.html">max_k</a>. Many opcodes have variants for either i-rate-variables or k-rate-variables, like <a href="http://csounds.com/manual/html/printf.html">printf_i</a> and <a href="http://csounds.com/manual/html/printf.html">printf</a>, <a href="http://csounds.com/manual/html/sprintf.html">sprintf</a> and <a href="http://csounds.com/manual/html/sprintf.html">sprintfk</a>, <a href="http://csounds.com/manual/html/strindex.html">strindex</a> and <a href="http://csounds.com/manual/html/strindexk.html">strindexk</a>.
  <br></p>
<p>Most of the Csound opcodes are able to work either at i-time or at k-time or at audio-rate, but you have to think carefully what you need, as the behaviour will be very different if you choose the i-, k- or a-variante of an opcode. For example, the <a href="http://csounds.com/manual/html/random.html">random</a> opcode can work at all three rates:
</p>
<pre>ires      random    imin, imax : works at "i-time"
kres      random    kmin, kmax : works at "k-rate"
ares      random    kmin, kmax : works at "audio-rate"
</pre>
<p>If you use the i-rate random generator, you will get one value for each note. For instance, if you want to have a different pitch for each note you are generating, you will use this one.
</p>
<p>If you use the k-rate random generator, you will get one new value on every control cycle. If your sample rate is 44100 and your ksmps=10, you will get 4410 new values per second! If you take this as pitch value for a note, you will hear nothing but a noisy jumping. If you want to have a moving pitch, you can use the <a href="http://csounds.com/manual/html/randomi.html">randomi</a> variant of the k-rate random generator, which can reduce the number of new values per second, and interpolate between them.
</p>
<p>If you use the a-rate random generator, you will get as many new values per second as your sample rate is. If you use it in the range of your 0 dB amplitude, you produce white noise.
</p>
<p>   <em><strong>EXAMPLE 03A15_Random_at_ika.csd</strong></em>  
</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
0dbfs = 1
nchnls = 2

          seed      0 ;each time different seed
giSine    ftgen     0, 0, 2^10, 10, 1 ;sine table

instr 1 ;i-rate random
iPch      random    300, 600
aAmp      linseg    .5, p3, 0
aSine     poscil    aAmp, iPch, giSine
          outs      aSine, aSine
endin

instr 2 ;k-rate random: noisy
kPch      random    300, 600
aAmp      linseg    .5, p3, 0
aSine     poscil    aAmp, kPch, giSine
          outs      aSine, aSine
endin

instr 3 ;k-rate random with interpolation: sliding pitch
kPch      randomi   300, 600, 3
aAmp      linseg    .5, p3, 0
aSine     poscil    aAmp, kPch, giSine
          outs      aSine, aSine
endin

instr 4 ;a-rate random: white noise
aNoise    random    -.1, .1
          outs      aNoise, aNoise
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0   .5
i 1 .25 .5
i 1 .5  .5
i 1 .75 .5
i 2 2   1
i 3 4   2
i 3 5   2
i 3 6   2
i 4 9   1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<h2>Possible Problems with k-Rate Tick Size
</h2>
<p>It has been said that usually the k-rate clock ticks much slower than the sample (a-rate) clock. For a common size of ksmps=32, one k-value remains the same for 32 samples. This can lead to problems, for instance if you use k-rate envelopes. Let us assume that you want to produce a very short fade-in of 3 milliseconds, and you do it with the following line of code:
</p>
<pre>kFadeIn linseg 0, .003, 1</pre>
<p>Your envelope will look like this:
</p>
<p><img src="static/03A_k-rate_env.png" height="280" width="489"><br><br>Such a "staircase-envelope" is what you hear in the next example as zipper noise. The transeg opcode produces a non-linear envelope with a sharp peak:
</p>
<p align="center"><img src="static/03A_peak.png" height="258" width="127"> 
</p>
<p>The rise and the decay are each 1/100 seconds long. If this envelope is produced at k-rate with a blocksize of 128 (instr 1), the noise is clearly audible. Try changing ksmps to 64, 32 or 16 and compare the amount of zipper noise. - Instrument 2 uses an envelope at audio-rate instead. Regardless the blocksize, each sample is calculated seperately, so the envelope will always be smooth.
</p>
<p>   <em><strong>EXAMPLE 03A16_Zipper.csd</strong></em>   
  <br></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
;--- increase or decrease to hear the difference more or less evident
ksmps = 128
nchnls = 2
0dbfs = 1

instr 1 ;envelope at k-time
aSine     oscils    .5, 800, 0
kEnv      transeg   0, .1, 5, 1, .1, -5, 0
aOut      =         aSine * kEnv
          outs      aOut, aOut
endin

instr 2 ;envelope at a-time
aSine     oscils    .5, 800, 0
aEnv      transeg   0, .1, 5, 1, .1, -5, 0
aOut      =         aSine * aEnv
          outs      aOut, aOut
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
r 5 ;repeat the following line 5 times
i 1 0 1
s ;end of section
r 5
i 2 0 1
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<h2>Time Impossible
  <br></h2>
<p>There are two internal clocks in Csound. The sample rate (sr) determines the audio-rate, whereas the control rate (kr) determines the rate, in which a new control cycle can be started and a new block of samples can be performed. In general, Csound can not start any event in between two control cycles, nor end.
</p>
<p>The next example chooses an extreme small control rate (only 10 k-cycles per second) to illustrate this.
  <br></p>
<p>   <em><strong>EXAMPLE 03A17_Time_Impossible.csd</strong></em>   
  <br></p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o test.wav -d
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 4410
nchnls = 1
0dbfs = 1

  instr 1
aPink oscils .5, 430, 0
out aPink
  endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0.05 0.1
i 1 0.4 0.15
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</pre>
<p>The first call advices instrument 1 to start performance at time 0.05. But this is impossible as it lies between two control cycles. The second call starts at a possible time, but the duration of 0.15 again does not coincident with the control rate. So the result starts the first call at time 0.1 and extends the second call to 0.2 seconds:
</p>
<p align="center"><img src="static/03A_Wrong_times.png" height="321" width="418"> 
</p>
<p> 
</p>
<p>With Csound6, the possibilities of these "in between" are enlarged via the --sample-accurate option. The next image shows how a 0.01 second envelope which is generated by the code
</p>
<pre>a1 init  1
a2 linen a1, p3/3, p3, p3/3
   out   a2
</pre>
<p>(and a call of 0.01 seconds at sr=44100) shows up in the following cases:
</p>
<ol><li> ksmps=128</li>
  <li>ksmps=32</li>
  <li>ksmps=1</li>
  <li>ksmps=128 and --sample-accurate enabled</li>
</ol><p><img src="static/03A_ksmps.png" height="248" width="600"> 
</p>
<p>This is the effect:
</p>
<ol><li> At ksmps=128, the last section of the envelope is missing. The reason is that, at sr=44100 Hz, 0.01 seconds contain 441 samples. 441 samples divided by the block size (ksmps) of 128 samples yield to 3.4453125 blocks. This is rounded to 3. So only 3 * 128 = 384 Samples are performed. As you see, the envelope itself is calculated correctly in its shape. It <em>would</em> end exactly at 0.01 seconds .. but it does not, because the ksmps block ends too early. So this envelope might introduce a click at the end of this note.</li>
  <li>At ksmps=32, the number of samples (441) divided by ksmps yield to a value of 13.78125. This is rounded to 18, so the rendered audio is slightly longer than 0.01 seconds (448 samples).</li>
  <li>At ksmps=1, the envelope is as expected.</li>
  <li>At ksmps=128 and --sample-accurate enabled, the envelope is correct, too. Note that the section is now 4*128=512 samples long, but the envelope is more accurate than at ksmps=32.
  <br></li>
</ol><p>So, in case you experience clicks at very short envelopes although you use a-rate envelopes, it might be necessary to set either ksmps=1, or to enable the --sample-accurate option.
  <br></p>
<h2>When to Use i- or k- Rate
</h2>
<p>When you code on your Csound instrument, you may sometimes wonder whether you shall use an i-rate or a k-rate opcode. From what is said, the general answer is clear: Use i-rate if something has to be done only once, or in a somehow punctual manner. Use k-rate if something has to be done continuously, or if you must regard what happens during the performance.
</p>
<br><p><span></span>
</p>
<ol id="InsertNote_NoteList"><li id="InsertNoteID_6">You would not get any other result if you set p3 to 1 or any other value, as nothing is done here except initialization.<span id="InsertNoteID_6_LinkBacks"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_6_marker7">^</a></sup></span></li>
  <li id="InsertNoteID_8">For the physical result which comes out of the loudspeakers or headphones, the variation is the variation of air pressure.<span id="InsertNoteID_8_LinkBacks"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_8_marker9">^</a></sup></span></li>
  <li id="InsertNoteID_10">44100 samples per second<span id="InsertNoteID_10_LinkBacks"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_10_marker11">^</a></sup></span></li>
  <li id="InsertNoteID_28">These are by the way the times which Csound reports if you ask for the control cycles. The first control cycle in this example (sr=44100, ksmps=10) would be reported as 0.00027 seconds, not as 0.00000 seconds.<span id="InsertNoteID_28_LinkBacks"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_28_marker29">^</a></sup></span></li>
  <li id="InsertNoteID_12">As Richard Boulanger explains, in early Csound a line starting with 'c' was a comment line. So it was not possible to abbreviate control variables as cAnything (http://csound.1045644.n5.nabble.com/OT-why-is-control-rate-called-kontrol-rate-td5720858.html#a5720866). <span id="InsertNoteID_12_LinkBacks"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_12_marker13">^</a></sup></span></li>
  <li id="InsertNoteID_14">As the k-rate is directly depending on sample rate (sr) and ksmps (kr = sr/ksmps), it is probably the best style to specify sr and ksmps in the header, but not kr. <span id="InsertNoteID_14_LinkBacks"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_14_marker15">^</a></sup></span></li>
  <li id="InsertNoteID_16">This must not be confused with a 'real' k-loop where inside one single k-cycle a loop is performed. See chapter 03C (section Loops) for examples.<span id="InsertNoteID_16_LinkBacks"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_16_marker17">^</a></sup></span></li>
  <li id="InsertNoteID_18">The value is 3110 instead of 3100 because it has already been incremented by 10.<span id="InsertNoteID_18_LinkBacks"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_18_marker19">^</a></sup></span></li>
  <li id="InsertNoteID_20">See the manual page for printk, printk2, printks, printf to know more about the differences.<span id="InsertNoteID_20_LinkBacks"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_20_marker21">^</a></sup></span></li>
  <li id="InsertNoteID_22">If you want to know the number in an instrument, use the nstrnum opcode. <span id="InsertNoteID_22_LinkBacks"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_22_marker23">^</a></sup></span></li>
  <li id="InsertNoteID_24">See the following section 03B about the variable types for more on this subject.<span id="InsertNoteID_24_LinkBacks"><sup><a href="a-initialization-and-performance-pass#InsertNoteID_24_marker25">^</a></sup></span></li>
</ol></body></html>
   
  </div>
 </div>


  </div>
</div>
<!-- End of content -->



<!-- sputnik error page -->
<div id="dialog-sputnik-qrac" style="display: none"></div>
<div id="dialog-sputnik-error" title="Can't communicate with booktype">
  <p>
    <span class="ui-icon ui-icon-circle-check" style="float:left; margin:0 7px 50px 0;"></span>
    There has been error in communication with Booktype server.
    Not sure right now where is the problem.
  </p>
  <p>
    You should refresh this page.
  </p>
</div>


<ul class="strings template">
 <li class="ok">OK</li>
 <li class="back">Back</li>
 <li class="create">Create</li>
 <li class="cancel">Cancel</li>
 <li class="next">Next</li>
 <li class="import">Import</li>
 <li class="savechanges">Save changes</li>
 <li class="errorcreategroup">Couldn't create a group!</li>
 <li class="msgepub">enter epub URL</li>
 <li class="msgarchive">enter Archive.org ID</li>
 <li class="msgwiki">enter Wikibooks URL</li>
 <li class="msgbooktype">enter Booktype URL</li>
 <li class="deletebook">Delete book</li>
</ul>

</body>
</html>

