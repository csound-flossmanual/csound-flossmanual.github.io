
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> 
<html>
 <head>
   <link type="text/css" href="http://www.flossmanuals.net/_templates/prettify/src/prettify.css" rel="Stylesheet" />
   <script type="text/javascript" src="http://www.flossmanuals.net/_templates/prettify/src/prettify.js"></script>

   <link type="text/css" href="/site_static/js/jquery/themes/base/jquery.ui.all.css" rel="Stylesheet" >
   <link type="text/css" href="/site_static/js/jquery/themes/smoothness/jquery.ui.all.css" rel="Stylesheet" >
   <script type="text/javascript" src="/static/js/jquery-1.7.js"></script>
<!--
   <script type="text/javascript" src="/site_static/js/jquery/jquery-1.4.4.js"></script>
-->   
<script type="text/javascript" src="/site_static/js/jquery/ui/jquery-ui-1.8.10.custom.js"></script>
   <script type="text/javascript" src="/site_static/js/jquery.json-1.3.js"></script>
   <script type="text/javascript" src="/site_static/js/booki.js"></script>

   <link href="/site_static/css/jquery.bubblepopup.v2.3.1.css" rel="stylesheet" type="text/css" />
   <script src="/site_static/js/jquery.bubblepopup.v2.3.1.min.js" type="text/javascript"></script>

   <link type="text/css" href="/static/css/booki_fm.css" rel="Stylesheet"/ >
<style>
.template {
	display: none !important;
}


#header {
    background-color: transparent !important;
}
.paginator { padding:.5em .75em; float:left; font:normal .8em arial; }
 
.paginator .prev-na,
.paginator .next-na {
	padding:.3em;
	font-weight: bold;
/*	font:bold .875em arial; */
}
 
.paginator .prev-na,
.paginator .next-na {
/*	border:1px solid #ccc; 
	background-color:#f9f9f9; */
	color:#aaa;
	font-weight:normal;
}
 
.paginator .prev a, .paginator .prev a:visited,
.paginator .next a, .paginator .next a:visited {
/*	border:1px solid #c2ee62; 
	background-color:#edfdd0; */
	color:#234f32;
	padding:.3em;
/*	font:bold .875em arial; */
        font-weight: bold;
}
 
.paginator .prev, .paginator .prev-na { margin-right:.5em; }
.paginator .next, .paginator .next-na { margin-left:.5em; }
 
.paginator .page a, .paginator .page a:visited, .paginator .curr {
	padding:.25em;
	font-weight: normal;
/*	font:normal .875em verdana; */
/*	border:1px solid #C2EE62; 
	background-color:#EDFDD0; */
	margin:0em .25em;	
	color:#006000;
}
 
.paginator .curr { 
/*	background-color:#234f32; 
	color:#fff; */
	border:1px solid #234f32; 
	font-weight:bold;
	font-size:1em;
}
 
.paginator .page a:hover,
.paginator .curr a:hover,
.paginator .prev a:hover,
.paginator .next a:hover {
/*	color:#fff;
	background-color:#234f32;
	border:1px solid #234f32; */
}
</style>
 <script type="text/javascript">
      $(function() {
   $.booki.sputnikDispatcherURL = "/_sputnik/";
    });
   </script>

   <script type="text/javascript">
     $(function() {
	 // open debug window
	 $.booki.debug.init();
	 
	 
	 $("A.debug").click(function() {
	     $("#bookidebug").dialog("open");
	     return false;
	 });
     });
   </script>

   
<title>/chapter: Random / CSound</title>
<link type="text/css" href="/site_static/css/editor.css" rel="Stylesheet" />

<script src="http://assets.annotateit.org/annotator/v1.2.5/annotator-full.min.js"></script>
<link rel="stylesheet" href="http://assets.annotateit.org/annotator/v1.2.5/annotator.min.css">



<link rel="alternate" type="application/rss+xml" title="RSS feed for CSound" href="/feeds/rss/book/csound/" /> 
<link rel="alternate" type="application/atom+xml" title="Atom feed for CSound" href="/feeds/atom/book/csound/" /> 

<link rel="alternate" type="application/rss+xml" title="RSS feed for chapter Random" href="/feeds/rss/chapter/csound/csound/" /> 
<link rel="alternate" type="application/atom+xml" title="Atom feed for chapter Random" href="/feeds/atom/chapter/csound/csound/" /> 


 </head>
<body onload="prettyPrint()" >
<!-- testis -->

<script type="text/javascript">
$(function() {
    $("#snippetdialog").dialog({autoOpen: false});
});
</script>


<div id="snippetdialog" title="Basic dialog">
        <p></p>
</div>



<div id="page-container"> 
<style>
body
{
margin:0;
padding:0
}
#header
{
position:absolute;
top:23px;
width:100%;
background-image: url('http://www.flossmanuals.net/_templates/fm_resources/header_bg.gif');
background-position: 700px 0px; /* this places the orange background at
an offset, making sure it doesn't underlap the left side of the gif */
background-repeat: no-repeat;
}

#fmheader {
    background-image: url("http://en.flossmanuals.net/_templates/fm_resources/header_bg.gif");
    background-position: 600px 0;
    background-repeat: no-repeat;
    position: absolute;
    top: 23px;
    width: 100%;
}
#header_image
{
margin-left: 270px;
border: 0px
}

#navigation
{
position:absolute;
top: 80px;
left: 357px;
width:50%;
}


#languages
{
position:absolute;
top: 40px;
left: 740px;
width:50%;
}
</style>



<!-- Header graphic is common to all pages  -->
<div id="header"><img id="header_image" alt="FlossManuals menu" src="http://www.flossmanuals.net/_templates/fm_resources/header_menu.gif" height="95" width="465" border="0"></div>


<!-- Navigation buttons are language and context specific  -->
<div id="navigation">
<a title="Read" href="http://en.flossmanuals.net/index.php"><img src="http://www.flossmanuals.net/_templates/fm_resources/read_en.png" width="65" height="30" border="0" alt="Read"></a>
<a title="Write" href="http://booki.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/write_active_en.png" width="65" height="30" border="0" alt="Write"></a>
<a title="Remix" href="http://en.flossmanuals.net/index.php?plugin=remix"><img src="http://www.flossmanuals.net/_templates/fm_resources/remix_en.png" width="65" height="30" border="0" alt="Remix"></a>
<a title="About" href="http://www.flossmanuals.org"><img src="http://www.flossmanuals.net/_templates/fm_resources/about_en.png" width="65" height="30" border="0" alt="About"></a>
</div>

<!-- Language buttons are common to all pages  -->
<div id="languages">
<a title="English" href="http://en.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/english_button.png" width="65" height="30" border="0" alt="English"></a>

<!-- <a title="Español" href="http://es.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/spanish_button.png" width="65" height="30" border="0" alt="Español"></a> -->
<a title="فارسی" href="http://fa.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/farsi_button.png" width="65" height="30" border="0" alt="فارسی"></a>
<a title="Suomi" href="http://fi.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/finnish_button.png" width="65" height="30" border="0" alt="Suomi"></a>
<br>
<a title="Français" href="http://fr.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/french_button.png" width="65" height="30" border="0" alt="Français"></a>
<a title="Nederlands" href="http://nl.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/dutch_button.png" width="65" height="30" border="0" alt="Nederlands"></a>
<!-- <a title="Pусский" href="http://ru.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/russian_button.png" width="65" height="30" border="0" alt="Pусский"></a> -->
<a title="Translate" href="http://translate.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/translate_button.png" width="65" height="30" border="0" alt="Translate"></a>
</div>

<!-- End top bar -->

<!-- nav box + drop shadow -->
<div class="navbox shadow" style="top:160px;">
    		<ul>

 		<li><a href="/accounts/signin/?redirect=/csound/_draft/_v/1.0/random/">Sign In</li><li>Register</a></li>

                <li><a href="/list-books">All Manuals</a></li>
                <li><a href="/list-groups">All Groups</a></li>
                <li><a href="/list-people/">All People</a></li>
           	</ul>
</div>
<!-- End of nav box -->



<div class="content-container shadow">
<!-- Content box and the drop shadow-->




<br clear="all"/>
   <h1>CSound</h1>


<div id="bookmenu"   style="background: url(/site_static/images/draft_bg.png) repeat !important;">
<ul>

 
   <li><b>INTRODUCTION</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/introduction/">PREFACE</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/how-to-use-this-manual/">HOW TO USE THIS MANUAL</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/on-this-release/">ON THIS RELEASE</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/credits/">CREDITS</a></li>
 

 
   <li><b>01 BASICS</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-digital-audio/">A. DIGITAL AUDIO</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-pitch-and-frequency/">B. PITCH AND FREQUENCY</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-intensities/">C. INTENSITIES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/random/">D. RANDOM</a></li>
 

 
   <li><b>02 QUICK START</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-make-csound-run/">A. MAKE CSOUND RUN</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-csound-syntax/">B. CSOUND SYNTAX</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-configuring-midi/">C. CONFIGURING MIDI</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-live-audio/">D. LIVE AUDIO</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/e-rendering-to-file/">E. RENDERING TO FILE</a></li>
 

 
   <li><b>03 CSOUND LANGUAGE</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-initialization-and-performance-pass/">A. INITIALIZATION AND PERFORMANCE PASS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-local-and-global-variables/">B. LOCAL AND GLOBAL VARIABLES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-control-structures/">C. CONTROL STRUCTURES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-function-tables/">D. FUNCTION TABLES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/arrays/">E. ARRAYS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/e-triggering-instrument-events/">F. LIVE EVENTS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/f-user-defined-opcodes/">G. USER DEFINED OPCODES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/macros/">H. MACROS</a></li>
 

 
   <li><b>04 SOUND SYNTHESIS</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-additive-synthesis/">A. ADDITIVE SYNTHESIS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-subtractive-synthesis/">B. SUBTRACTIVE SYNTHESIS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-amplitude-and-ringmodulation/">C. AMPLITUDE AND RING MODULATION</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-frequency-modulation/">D. FREQUENCY MODULATION</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/e-waveshaping/">E. WAVESHAPING</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/f-granular-synthesis/">F. GRANULAR SYNTHESIS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/g-physical-modelling/">G. PHYSICAL MODELLING</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/scanned-synthesis/">H. SCANNED SYNTHESIS</a></li>
 

 
   <li><b>05 SOUND MODIFICATION</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-envelopes/">A. ENVELOPES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-panning-and-spatialization/">B. PANNING AND SPATIALIZATION</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-filters/">C. FILTERS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-delay-and-feedback/">D. DELAY AND FEEDBACK</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/e-reverberation/">E. REVERBERATION</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/f-am-rm-waveshaping/">F. AM / RM / WAVESHAPING</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/g-granular-synthesis/">G. GRANULAR SYNTHESIS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/h-convolution/">H. CONVOLUTION</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/i-fourier-analysis-spectral-processing/">I. FOURIER ANALYSIS / SPECTRAL PROCESSING</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/k-ats-resynthesis/">K. ATS RESYNTHESIS</a></li>
 

 
   <li><b>06 SAMPLES</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-record-and-play-soundfiles/">A. RECORD AND PLAY SOUNDFILES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-record-and-play-buffers/">B. RECORD AND PLAY BUFFERS</a></li>
 

 
   <li><b>07 MIDI</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-receiving-events-by-midiin/">A. RECEIVING EVENTS BY MIDIIN</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-triggering-instrument-instances/">B. TRIGGERING INSTRUMENT INSTANCES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-working-with-controllers/">C. WORKING WITH CONTROLLERS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-reading-midi-files/">D. READING MIDI FILES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/e-midi-output/">E. MIDI OUTPUT</a></li>
 

 
   <li><b>08 OTHER COMMUNICATION</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/osc-and-wii/">A. OPEN SOUND CONTROL</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/csound-in-arduino/">B. CSOUND AND ARDUINO</a></li>
 

 
   <li><b>09 CSOUND IN OTHER APPLICATIONS</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/csound-in-pd/">A. CSOUND IN PD</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/csound-in-maxmsp/">B. CSOUND IN MAXMSP</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/csound-in-ableton-live/">C. CSOUND IN ABLETON LIVE</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-csound-as-a-vst-plugin/">D. CSOUND AS A VST PLUGIN</a></li>
 

 
   <li><b>10 CSOUND FRONTENDS</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/qutecsound/">CSOUNDQT</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/cecilia/">CABBAGE</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/blue/">BLUE</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/winxound/">WINXOUND</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/csound-via-terminal/">CSOUND VIA TERMINAL</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/web-based-csound/">WEB BASED CSOUND</a></li>
 

 
   <li><b>11 CSOUND UTILITIES</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/csound-utilities/">CSOUND UTILITIES</a></li>
 

 
   <li><b>12 CSOUND AND OTHER PROGRAMMING LANGUAGES</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/the-csound-api/">A. THE CSOUND API</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/using-python-inside-csound/">B. PYTHON INSIDE CSOUND</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-python-in-csoundqt/">C. PYTHON IN CSOUNDQT</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-lua-in-csound/">D. LUA IN CSOUND</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/e-csound-in-ios/">E. CSOUND IN iOS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/f-csound-on-android/">F. CSOUND ON ANDROID</a></li>
 

 
   <li><b>13 EXTENDING CSOUND</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/extending-csound/">EXTENDING CSOUND</a></li>
 

 
   <li><b>OPCODE GUIDE</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/overview/">OVERVIEW</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/signal-processing-i/">SIGNAL PROCESSING I</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/signal-processing-ii/">SIGNAL PROCESSING II</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/data/">DATA</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/realtime-interaction/">REALTIME INTERACTION</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/instrument-control/">INSTRUMENT CONTROL</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/math-pythonsystem-plugins/">MATHS, PYTHON/SYSTEM, PLUGINS</a></li>
 

 
   <li><b>APPENDIX</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/writing-csound-scores-by-hand/">METHODS OF WRITING CSOUND SCORES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/glossary/">GLOSSARY</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/links/">LINKS</a></li>
 

</ul>
</div>
<div id="bookcontent"   >
<h1>RANDOM
</h1>
<p>This chapter is divided in three main parts. Part I is a general introduction into the field of random numbers and how to work with them in Csound. Part II is highlighting some aspects from a more mathematical point of view. Part III collects some musically interesting examples.
  <br />
</p>
<h2>I. GENERAL INTRODUCTION
  <br />
</h2>
<h3>Random is Different
  <br />
</h3>
<p>The term <em>random</em> derives from a horse which is running fast so that it is in a way "out of control" or "out of predictability".<span class="InsertNoteMarker" id="InsertNoteID_6_marker7"><sup><a href="#InsertNoteID_6">1</a></sup></span>&nbsp; But there are very different ways to run fast, very different ways to be out of control. And so there are very different ways of "random".
</p>
<p>We can divide possible ways of random in two classes. The first one contains random events which are independent from any previous event. The most common example for this is throwing a die. Even if you have thrown three times a "1", in the next cast the "1" has the same probability than before. The second class contains random events which depend in any way on the previous state(s). Examples here are Markov Chains and Random Walks.
  <br />
</p>
<p><img src="static/random_overview.png" height="315" width="599" />&nbsp;
</p>
<p>The usage of random in electronic music is widespread. In this chapter, we will mostly try to explain how the different random horses are moving, and how you can create and modify them by your own. Moreover, there are many pre-built random opcodes in Csound which can be used out of the box (see the <a href="http://www.csounds.com/manual/html/SiggenNoise.html">overview</a> in the Csound Manual). The end of this chapter collects some musically interesting applications of them.
  <br />
</p>
<h2>Random Without History
  <br />
</h2>
<p>A usual computer is only capable of computations. Computations are <em>deterministic</em> processes: one input will generate the same output all the time. But a random event is not predictable. To generate something which <em>looks like</em> a random event, the computer uses a pseudo-random generator.
</p>
<p>The pseudo-random generator takes one number as input, and generates another number as output. This output is then the input for the next generation. For a huge amount of numbers, they look as if they are randomly distributed, although everything depends on the first input: the <em>seed</em>. For one given seed, the next values can be predicted.
  <br />
</p>
<h3>Uniform Distribution
  <br />
</h3>
<p>The output of a classical pseudo-random generator is uniformly distributed: Each value in a given range has the same probability. The first example shows the influence of a fixed seed (giving the same chain of numbers all the time) against a seed which is taken from the system clock (the usual way of being "real" unpredictable). The first three groups of four notes will always be the same because of the same seed; the last three groups should always sound in a different pitch.
</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 01D01_different_seed.csd</strong></em>
  <br />
</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-d -odac -m0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

instr generate
 ;get seed: 0 = seeding from system clock
 ;          otherwise = fixed seed
           seed       p4
 ;generate four notes to be played from subinstrument
iNoteCount =          0
 until iNoteCount == 4 do
iFreq      random     400, 800
           event_i    "i", "play", iNoteCount, 2, iFreq
iNoteCount +=         1 ;increase note count
 enduntil
endin

instr play
iFreq      =          p4
           print      iFreq
aImp       mpulse     .5, p3
aMode      mode       aImp, iFreq, 1000
aEnv       linen      aMode, 0.01, p3, p3-0.01
           outs       aEnv, aEnv
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;repeat three times with fixed seed
r 3
i "generate" 0 2 1
;repeat three times with seed from the system clock
r 3
i "generate" 0 1 0
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>Note that a pseudo-random generator will repeat its series of numbers after as many steps as are given by the size of the generator. If a 16-bit number is generated, the series will be repeated after 65536 steps. If you listen carefully to the following example, you will hear a repetition in the structure of the white noise (which is the result of uniformly distributed amplitudes) after about 1.5 seconds in the first note.<span class="InsertNoteMarker" id="InsertNoteID_8_marker9"><sup><a href="#InsertNoteID_8">2</a></sup></span>&nbsp; In the second note, there is no audible repetition, because the random generator now works with a 31-bit number.
  <br />
</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 01D02_white_noises.csd</strong></em>&nbsp;
  <br />
</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-d -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

instr white_noise
iBit       =          p4 ;0 = 16 bit, 1 = 31 bit
 ;input of rand: amplitude, fixed seed (0.5), bit size
aNoise     rand       .1, 0.5, iBit
           outs       aNoise, aNoise
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i "white_noise" 0 10 0
i "white_noise" 11 10 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>Two more general notes about this:
</p>
<ol>
  <li> The way of setting the seed is different from opcode to opcode. There are several opcodes, like the above used <a href="http://www.csounds.com/manual/html/rand.html">rand</a>, which have the choice of setting a seed as input parameter. For some others, like the frequently used <a href="http://www.csounds.com/manual/html/random.html">random</a> family, the seed can only be set globally, via the <a href="http://www.csounds.com/manual/html/seed.html">seed</a> statement. This is usually done in the header; so a typical statement would be:
  <br />
  <pre>&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1
seed = 0 ;seeding from current time
<p>...
</p></pre></li>
  <li> Random generation in Csound can be done at any rate. The type of the output variable tells you whether you are generating random values at i-, k- or a-rate. Many random opcodes can work at all these rates, for instance random:
  <br />
  <pre>1) ires  random  imin, imax
2) kres  random  kmin, kmax
3) ares  random  kmin, kmax
</pre>In the first case, a random value is generated only once, when an instrument is called, at initialization. The generated value is then stored in the variable <em>ires</em>. In the second case, a random value is generated at each k-cycle, and stored in <em>kres</em>. In the third case, in each k-cycle as many random values are stored as the audio vector has in size, and stored in the variable <em>ares</em>. Have a look at example <em>03A12_Random_at_ika.csd</em> to see this at work. Chapter 03A tries to explain the background of the different rates in depth, and how to work with them. &nbsp;</li>
</ol>
<h3>Other Distributions
  <br />
</h3>
<p>The uniform distribution is the one each computer can output via its pseudo-random generator. But there are many situations you will not want a uniformly distributed random, but any other shape. Some of these shapes are quite common, but actually you can build your own shape quite easily in Csound. The next examples try to show how to do this. They are based on the chapter in Dodge/Jerse<span class="InsertNoteMarker" id="InsertNoteID_22_marker23"><sup><a href="#InsertNoteID_22">3</a></sup></span>&nbsp; which also served as model for many random opcodes in Csound.<span class="InsertNoteMarker" id="InsertNoteID_24_marker25"><sup><a href="#InsertNoteID_24">4</a></sup></span>&nbsp;
  <br />
</p>
<h4>Linear
</h4>
<p>A linear distribution means that either lower or higher values in a given range are more likely:
</p>
<p> <img src="static/01D_linear_distributionA2.png" height="338" width="451" />
  <br />
</p>
<p>&nbsp;
  <br />
</p>
<p> <img src="static/01D_linear_distributionB2.png" height="338" width="450" />
  <br />
</p>
<p>To get this behaviour, two uniform random numbers are generated, and the lower is taken for the first shape. If the second shape with the precedence of higher values is needed, the higher one of the two generated numbers is taken. The next example implements these random generators as User Defined Opcodes. First we hear a uniform distribution, then a linear distribution with precedence of lower pitches (but longer durations), at least a linear distribution with precedence of higher pitches (but shorter durations).
  <br />
</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 01D03_linrand.csd</strong></em>&nbsp;&nbsp;
  <br />
</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-d -odac -m0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1
seed 0

;****DEFINE OPCODES FOR LINEAR DISTRIBUTION****

opcode linrnd_low, i, ii
 ;linear random with precedence of lower values
iMin, iMax xin
 ;generate two random values with the random opcode
iOne       random     iMin, iMax
iTwo       random     iMin, iMax
 ;compare and get the lower one
iRnd       =          iOne &lt; iTwo ? iOne : iTwo
           xout       iRnd
endop

opcode linrnd_high, i, ii
 ;linear random with precedence of higher values
iMin, iMax xin
 ;generate two random values with the random opcode
iOne       random     iMin, iMax
iTwo       random     iMin, iMax
 ;compare and get the higher one
iRnd       =          iOne &gt; iTwo ? iOne : iTwo
           xout       iRnd
endop


;****INSTRUMENTS FOR THE DIFFERENT DISTRIBUTIONS****

instr notes_uniform
           prints     "... instr notes_uniform playing:\n"
           prints     "EQUAL LIKELINESS OF ALL PITCHES AND DURATIONS\n"
 ;how many notes to be played
iHowMany   =          p4
 ;trigger as many instances of instr play as needed
iThisNote  =          0
iStart     =          0
 until iThisNote == iHowMany do
iMidiPch   random     36, 84 ;midi note
iDur       random     .5, 1 ;duration
           event_i    "i", "play", iStart, iDur, int(iMidiPch)
iStart     +=         iDur ;increase start
iThisNote  +=         1 ;increase counter
 enduntil
 ;reset the duration of this instr to make all events happen
p3         =          iStart + 2
 ;trigger next instrument two seconds after the last note
           event_i    "i", "notes_linrnd_low", p3, 1, iHowMany
endin

instr notes_linrnd_low
           prints     "... instr notes_linrnd_low playing:\n"
           prints     "LOWER NOTES AND LONGER DURATIONS PREFERRED\n"
iHowMany   =          p4
iThisNote  =          0
iStart     =          0
 until iThisNote == iHowMany do
iMidiPch   linrnd_low 36, 84 ;lower pitches preferred
iDur       linrnd_high .5, 1 ;longer durations preferred
           event_i    "i", "play", iStart, iDur, int(iMidiPch)
iStart     +=         iDur
iThisNote  +=         1
 enduntil
 ;reset the duration of this instr to make all events happen
p3         =          iStart + 2
 ;trigger next instrument two seconds after the last note
           event_i    "i", "notes_linrnd_high", p3, 1, iHowMany
endin

instr notes_linrnd_high
           prints     "... instr notes_linrnd_high playing:\n"
           prints     "HIGHER NOTES AND SHORTER DURATIONS PREFERRED\n"
iHowMany   =          p4
iThisNote  =          0
iStart     =          0
 until iThisNote == iHowMany do
iMidiPch   linrnd_high 36, 84 ;higher pitches preferred
iDur       linrnd_low .3, 1.2 ;shorter durations preferred
           event_i    "i", "play", iStart, iDur, int(iMidiPch)
iStart     +=         iDur
iThisNote  +=         1
 enduntil
 ;reset the duration of this instr to make all events happen
p3         =          iStart + 2
 ;call instr to exit csound
           event_i    "i", "exit", p3+1, 1
endin


;****INSTRUMENTS TO PLAY THE SOUNDS AND TO EXIT CSOUND****

instr play
 ;increase duration in random range
iDur       random     p3, p3*1.5
p3         =          iDur
 ;get midi note and convert to frequency
iMidiNote  =          p4
iFreq      cpsmidinn  iMidiNote
 ;generate note with karplus-strong algorithm
aPluck     pluck      .2, iFreq, iFreq, 0, 1
aPluck     linen      aPluck, 0, p3, p3
 ;filter
aFilter    mode       aPluck, iFreq, .1
 ;mix aPluck and aFilter according to MidiNote
 ;(high notes will be filtered more)
aMix       ntrpol     aPluck, aFilter, iMidiNote, 36, 84
 ;panning also according to MidiNote
 ;(low = left, high = right)
iPan       =          (iMidiNote-36) / 48
aL, aR     pan2       aMix, iPan
           outs       aL, aR
endin

instr exit
           exitnow
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i "notes_uniform" 0 1 23 ;set number of notes per instr here
;instruments linrnd_low and linrnd_high are triggered automatically
e 99999 ;make possible to perform long (exit will be automatically)
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<h4>Triangular
</h4>
<p>In a triangular distribution the values in the middle of the given range are more likely than at the borders. The probability transition between the middle and the extrema are linear:
  <br />
</p>
<p><img src="static/01D_triangular_distribution.png" height="257" width="599" />
  <br />
</p>
<p>The algorithm for getting this distribution is very simple as well. Generate two uniform random numbers and take the mean of them. The next example shows the difference between uniform and triangular distribution in the same environment as the previous example.
</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 01D04_trirand.csd</strong></em>&nbsp;&nbsp;&nbsp;
  <br />
</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-d -odac -m0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1
seed 0

;****UDO FOR TRIANGULAR DISTRIBUTION****
opcode trirnd, i, ii
iMin, iMax xin
 ;generate two random values with the random opcode
iOne       random     iMin, iMax
iTwo       random     iMin, iMax
 ;get the mean and output
iRnd       =          (iOne+iTwo) / 2
           xout       iRnd
endop

;****INSTRUMENTS FOR UNIFORM AND TRIANGULAR DISTRIBUTION****

instr notes_uniform
           prints     "... instr notes_uniform playing:\n"
           prints     "EQUAL LIKELINESS OF ALL PITCHES AND DURATIONS\n"
 ;how many notes to be played
iHowMany   =          p4
 ;trigger as many instances of instr play as needed
iThisNote  =          0
iStart     =          0
 until iThisNote == iHowMany do
iMidiPch   random     36, 84 ;midi note
iDur       random     .25, 1.75 ;duration
           event_i    "i", "play", iStart, iDur, int(iMidiPch)
iStart     +=         iDur ;increase start
iThisNote  +=         1 ;increase counter
 enduntil
 ;reset the duration of this instr to make all events happen
p3         =          iStart + 2
 ;trigger next instrument two seconds after the last note
           event_i    "i", "notes_trirnd", p3, 1, iHowMany
endin

instr notes_trirnd
           prints     "... instr notes_trirnd playing:\n"
           prints     "MEDIUM NOTES AND DURATIONS PREFERRED\n"
iHowMany   =          p4
iThisNote  =          0
iStart     =          0
 until iThisNote == iHowMany do
iMidiPch   trirnd     36, 84 ;medium pitches preferred
iDur       trirnd     .25, 1.75 ;medium durations preferred
           event_i    "i", "play", iStart, iDur, int(iMidiPch)
iStart     +=         iDur
iThisNote  +=         1
 enduntil
 ;reset the duration of this instr to make all events happen
p3         =          iStart + 2
 ;call instr to exit csound
           event_i    "i", "exit", p3+1, 1
endin


;****INSTRUMENTS TO PLAY THE SOUNDS AND EXIT CSOUND****

instr play
 ;increase duration in random range
iDur       random     p3, p3*1.5
p3         =          iDur
 ;get midi note and convert to frequency
iMidiNote  =          p4
iFreq      cpsmidinn  iMidiNote
 ;generate note with karplus-strong algorithm
aPluck     pluck      .2, iFreq, iFreq, 0, 1
aPluck     linen      aPluck, 0, p3, p3
 ;filter
aFilter    mode       aPluck, iFreq, .1
 ;mix aPluck and aFilter according to MidiNote
 ;(high notes will be filtered more)
aMix       ntrpol     aPluck, aFilter, iMidiNote, 36, 84
 ;panning also according to MidiNote
 ;(low = left, high = right)
iPan       =          (iMidiNote-36) / 48
aL, aR     pan2       aMix, iPan
           outs       aL, aR
endin

instr exit
           exitnow
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i "notes_uniform" 0 1 23 ;set number of notes per instr here
;instr trirnd will be triggered automatically
e 99999 ;make possible to perform long (exit will be automatically)
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<h4>More Linear and Triangular
  <br />
</h4>
<p>Having written this with some very simple UDOs, it is easy to emphasize the probability peaks of the distributions by generating more than two random numbers. If you generate three numbers and choose the smallest of them, you will get much more numbers near the minimum in total for the linear distribution. If you generate three random numbers and take the mean of them, you will get more numbers near the middle in total for the triangular distribution.
</p>
<p>If we want to write UDOs with a flexible number of sub-generated numbers, we have to write the code in a slightly different way. Instead of having one line of code for each random generator, we will use a loop, which calls the generator as many times as we wish to have units. A variable will store the results of the accumulation. Re-writing the above code for the UDO <em>trirnd</em> would lead to this formulation:
</p>
<pre>opcode trirnd, i, ii
iMin, iMax xin
 ;set a counter and a maximum count
iCount     =          0
iMaxCount  =          2
 ;set the accumulator to zero as initial value
iAccum     =          0
 ;perform loop and accumulate
 until iCount == iMaxCount do
iUniRnd    random     iMin, iMax
iAccum     +=         iUniRnd
iCount     +=         1
 enduntil
 ;get the mean and output
iRnd       =          iAccum / 2
           xout       iRnd
endop</pre>
<p>To get this completely flexible, you only have to get <em>iMaxCount</em> as input argument. The code for the linear distribution UDOs is quite similar. -- The next example shows these steps:
</p>
<ol>
  <li>Uniform distribution.</li>
  <li>Linear distribution with the precedence of lower pitches and longer durations, generated with two units.</li>
  <li>The same but with four units.</li>
  <li>Linear distribution with the precedence of higher pitches and shorter durations, generated with two units.</li>
  <li>The same but with four units.</li>
  <li>Triangular distribution with the precedence of both medium pitches and durations, generated with two units.</li>
  <li>The same but with six units.</li>
</ol>
<p>Rather than using different instruments for the different distributions, the next example combines all possibilities in one single instrument. Inside the loop which generates as many notes as desired by the <em>iHowMany</em> argument, an if-branch calculates the pitch and duration of one note depending on the distribution type and the number of sub-units used. The whole sequence (which type first, which next, etc) is stored in the global array <em>giSequence</em>. Each instance of instrument "notes" increases the pointer giSeqIndx, so that for the next run the next element in the array is being read. If the pointer has reached the end of the array, the instrument which exits Csound is called instead of a new instance of "notes".
  <br />
</p>
<ol>
</ol>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 01D05_more_lin_tri_units.csd</strong></em>&nbsp;&nbsp;&nbsp;&nbsp;
  <br />
</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-d -odac -m0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1
seed 0

;****SEQUENCE OF UNITS AS ARRAY****/
giSequence[] array 0, 1.2, 1.4, 2.2, 2.4, 3.2, 3.6
giSeqIndx = 0 ;startindex

;****UDO DEFINITIONS****
opcode linrnd_low, i, iii
 ;linear random with precedence of lower values
iMin, iMax, iMaxCount xin
 ;set counter and initial (absurd) result
iCount     =          0
iRnd       =          iMax
 ;loop and reset iRnd
 until iCount == iMaxCount do
iUniRnd    random     iMin, iMax
iRnd       =          iUniRnd &lt; iRnd ? iUniRnd : iRnd
iCount     +=         1
 enduntil
           xout       iRnd
endop

opcode linrnd_high, i, iii
 ;linear random with precedence of higher values
iMin, iMax, iMaxCount xin
 ;set counter and initial (absurd) result
iCount     =          0
iRnd       =          iMin
 ;loop and reset iRnd
 until iCount == iMaxCount do
iUniRnd    random     iMin, iMax
iRnd       =          iUniRnd &gt; iRnd ? iUniRnd : iRnd
iCount     +=         1
 enduntil
           xout       iRnd
endop

opcode trirnd, i, iii
iMin, iMax, iMaxCount xin
 ;set a counter and accumulator
iCount     =          0
iAccum     =          0
 ;perform loop and accumulate
 until iCount == iMaxCount do
iUniRnd    random     iMin, iMax
iAccum     +=         iUniRnd
iCount     +=         1
 enduntil
 ;get the mean and output
iRnd       =          iAccum / iMaxCount
           xout       iRnd
endop

;****ONE INSTRUMENT TO PERFORM ALL DISTRIBUTIONS****
;0 = uniform, 1 = linrnd_low, 2 = linrnd_high, 3 = trirnd
;the fractional part denotes the number of units, e.g.
;3.4 = triangular distribution with four sub-units

instr notes
 ;how many notes to be played
iHowMany   =          p4
 ;by which distribution with how many units
iWhich     =          giSequence[giSeqIndx]
iDistrib   =          int(iWhich)
iUnits     =          round(frac(iWhich) * 10)
 ;set min and max duration
iMinDur    =          .1
iMaxDur    =          2
 ;set min and max pitch
iMinPch    =          36
iMaxPch    =          84

 ;trigger as many instances of instr play as needed
iThisNote  =          0
iStart     =          0
iPrint     =          1

 ;for each note to be played
 until iThisNote == iHowMany do

  ;calculate iMidiPch and iDur depending on type
  if iDistrib == 0 then
           printf_i   "%s", iPrint, "... uniform distribution:\n"
           printf_i   "%s", iPrint, "EQUAL LIKELINESS OF ALL PITCHES AND DURATIONS\n"
iMidiPch   random     iMinPch, iMaxPch ;midi note
iDur       random     iMinDur, iMaxDur ;duration
  elseif iDistrib == 1 then
           printf_i    "... linear low distribution with %d units:\n", iPrint, iUnits
           printf_i    "%s", iPrint, "LOWER NOTES AND LONGER DURATIONS PREFERRED\n"
iMidiPch   linrnd_low iMinPch, iMaxPch, iUnits
iDur       linrnd_high iMinDur, iMaxDur, iUnits
  elseif iDistrib == 2 then
           printf_i    "... linear high distribution with %d units:\n", iPrint, iUnits
           printf_i    "%s", iPrint, "HIGHER NOTES AND SHORTER DURATIONS PREFERRED\n"
iMidiPch   linrnd_high iMinPch, iMaxPch, iUnits
iDur       linrnd_low iMinDur, iMaxDur, iUnits
  else
           printf_i    "... triangular distribution with %d units:\n", iPrint, iUnits
           printf_i    "%s", iPrint, "MEDIUM NOTES AND DURATIONS PREFERRED\n"
iMidiPch   trirnd     iMinPch, iMaxPch, iUnits
iDur       trirnd     iMinDur, iMaxDur, iUnits
  endif

 ;call subinstrument to play note
           event_i    "i", "play", iStart, iDur, int(iMidiPch)

 ;increase start tim and counter
iStart     +=         iDur
iThisNote  +=         1
 ;avoid continuous printing
iPrint     =          0
 enduntil

 ;reset the duration of this instr to make all events happen
p3         =          iStart + 2

 ;increase index for sequence
giSeqIndx  +=         1
 ;call instr again if sequence has not been ended
 if giSeqIndx &lt; lenarray(giSequence) then
           event_i    "i", "notes", p3, 1, iHowMany
 ;or exit
 else
           event_i    "i", "exit", p3, 1
 endif
endin


;****INSTRUMENTS TO PLAY THE SOUNDS AND EXIT CSOUND****
instr play
 ;increase duration in random range
iDur       random     p3, p3*1.5
p3         =          iDur
 ;get midi note and convert to frequency
iMidiNote  =          p4
iFreq      cpsmidinn  iMidiNote
 ;generate note with karplus-strong algorithm
aPluck     pluck      .2, iFreq, iFreq, 0, 1
aPluck     linen      aPluck, 0, p3, p3
 ;filter
aFilter    mode       aPluck, iFreq, .1
 ;mix aPluck and aFilter according to MidiNote
 ;(high notes will be filtered more)
aMix       ntrpol     aPluck, aFilter, iMidiNote, 36, 84
 ;panning also according to MidiNote
 ;(low = left, high = right)
iPan       =          (iMidiNote-36) / 48
aL, aR     pan2       aMix, iPan
           outs       aL, aR
endin

instr exit
           exitnow
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i "notes" 0 1 23 ;set number of notes per instr here
e 99999 ;make possible to perform long (exit will be automatically)
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>We can build with this method probability distributions which are very similar to exponential or gaussian distributions.<span class="InsertNoteMarker" id="InsertNoteID_7_marker8"><sup><a href="#InsertNoteID_7">5</a></sup></span>&nbsp; Their shape can be formed easily by the number of sub-units used.
</p>
<h4> Scalings
  <br />
</h4>
<p>Random is a complex and sensible context. There are so many ways to let the horse go, run, or dance -- the conditions you set for this "way of moving" are much more important than the fact that one singe move is not predictable. Which are the conditions for a random context?
</p>
<ul>
  <li> <em>Which Way.</em> This is which has already been described: random with or without history, which probability distribution, etc.&nbsp;</li>
  <li><em>Which Range.</em> This is a decision which comes from the composer/programmer. In the example above I have chosen pitches from Midi Note 36 to 84 (C2 to C6), and durations between 0.1 and 2 seconds. Imagine how it would have been sounded with pitches from 60 to 67, and durations from 0.9 to 1.1 seconds, or from 0.1 to 0.2 seconds. There is no range which is self-confident; everything depends on the musical idea.</li>
  <li><em>Which Development.</em> Usually the boundaries will change in the run of a piece. The pitch range may move from low to high, or from narrow to wide; the durations may become shorter, etc pp.</li>
  <li><em>Which Scalings.</em> Let us think about this more in detail.</li>
</ul>
<p>In the example above we used two implicit scalings. The pitches have been scaled to the keys of a piano or keyboard. Why? We do not play piano here, obviously ... -- Which other possibilities would have been instead? One would be: no scaling at all. This is the easiest way to go -- whether it is really the best, or simple laziness, can only be decided by the composer or the listener.
</p>
<p>Instead of using the equal tempered chromatic scale, or no scale at all, you can use any other way of selecting or quantizing pitches. Be it any which has been, or is still, used in any part of the world, or be it your own invention, by whatever phantasy or invention or system.
</p>
<p>As to the durations, the example above has shown no scaling at all. This was definitely laziness ...
</p>
<p>So, the next example is essentially the same as the previous one. But it uses a pitch scale which represents the overtone scale, starting at the second partial, until partial 32. This scale is written in an array by a statement in instrument 0. The durations have fixed possible values which are written in an array (from the longest to the shortest) by hand. The values in both arrays are then called by their position.
</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 01D06_scalings.csd</strong></em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <br />
</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-d -odac -m0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1
seed 0


;****POSSIBLE DURATIONS AS ARRAY****
giDurs[]   array      3/2, 1, 2/3, 1/2, 1/3, 1/4
giLenDurs  lenarray   giDurs

;****POSSIBLE PITCHES AS ARRAY****
 ;initialize array with 31 steps
giScale[]  init       31
giLenScale lenarray   giScale
 ;iterate to fill from 65 hz onwards
iStart     =          65
iDenom     =          3 ;start with 3/2
iCnt       =          0
 until iCnt = giLenScale do
giScale[iCnt] =       iStart
iStart     =          iStart * iDenom / (iDenom-1)
iDenom     +=         1 ;next proportion is 4/3 etc
iCnt       +=         1
 enduntil

;****SEQUENCE OF UNITS AS ARRAY****
giSequence[] array    0, 1.2, 1.4, 2.2, 2.4, 3.2, 3.6
giSeqIndx  =          0 ;startindex

;****UDO DEFINITIONS****
opcode linrnd_low, i, iii
 ;linear random with precedence of lower values
iMin, iMax, iMaxCount xin
 ;set counter and initial (absurd) result
iCount     =          0
iRnd       =          iMax
 ;loop and reset iRnd
 until iCount == iMaxCount do
iUniRnd    random     iMin, iMax
iRnd       =          iUniRnd &lt; iRnd ? iUniRnd : iRnd
iCount += 1
enduntil
           xout       iRnd
endop

opcode linrnd_high, i, iii
 ;linear random with precedence of higher values
iMin, iMax, iMaxCount xin
 ;set counter and initial (absurd) result
iCount     =          0
iRnd       =          iMin
 ;loop and reset iRnd
 until iCount == iMaxCount do
iUniRnd    random     iMin, iMax
iRnd       =          iUniRnd &gt; iRnd ? iUniRnd : iRnd
iCount += 1
enduntil
           xout       iRnd
endop

opcode trirnd, i, iii
iMin, iMax, iMaxCount xin
 ;set a counter and accumulator
iCount     =          0
iAccum     =          0
 ;perform loop and accumulate
 until iCount == iMaxCount do
iUniRnd    random     iMin, iMax
iAccum += iUniRnd
iCount += 1
enduntil
 ;get the mean and output
iRnd       =          iAccum / iMaxCount
           xout       iRnd
endop

;****ONE INSTRUMENT TO PERFORM ALL DISTRIBUTIONS****
;0 = uniform, 1 = linrnd_low, 2 = linrnd_high, 3 = trirnd
;the fractional part denotes the number of units, e.g.
;3.4 = triangular distribution with four sub-units

instr notes
 ;how many notes to be played
iHowMany   =          p4
 ;by which distribution with how many units
iWhich     =          giSequence[giSeqIndx]
iDistrib   =          int(iWhich)
iUnits     =          round(frac(iWhich) * 10)

 ;trigger as many instances of instr play as needed
iThisNote  =          0
iStart     =          0
iPrint     =          1

 ;for each note to be played
 until iThisNote == iHowMany do

  ;calculate iMidiPch and iDur depending on type
  if iDistrib == 0 then
           printf_i   "%s", iPrint, "... uniform distribution:\n"
           printf_i   "%s", iPrint, "EQUAL LIKELINESS OF ALL PITCHES AND DURATIONS\n"
iScaleIndx random     0, giLenScale-.0001 ;midi note
iDurIndx   random     0, giLenDurs-.0001 ;duration
  elseif iDistrib == 1 then
           printf_i   "... linear low distribution with %d units:\n", iPrint, iUnits
           printf_i   "%s", iPrint, "LOWER NOTES AND LONGER DURATIONS PREFERRED\n"
iScaleIndx linrnd_low 0, giLenScale-.0001, iUnits
iDurIndx   linrnd_low 0, giLenDurs-.0001, iUnits
  elseif iDistrib == 2 then
           printf_i   "... linear high distribution with %d units:\n", iPrint, iUnits
           printf_i   "%s", iPrint, "HIGHER NOTES AND SHORTER DURATIONS PREFERRED\n"
iScaleIndx linrnd_high 0, giLenScale-.0001, iUnits
iDurIndx   linrnd_high 0, giLenDurs-.0001, iUnits
           else
           printf_i   "... triangular distribution with %d units:\n", iPrint, iUnits
           printf_i   "%s", iPrint, "MEDIUM NOTES AND DURATIONS PREFERRED\n"
iScaleIndx trirnd     0, giLenScale-.0001, iUnits
iDurIndx   trirnd     0, giLenDurs-.0001, iUnits
  endif

 ;call subinstrument to play note
iDur       =          giDurs[int(iDurIndx)]
iPch       =          giScale[int(iScaleIndx)]
           event_i    "i", "play", iStart, iDur, iPch

 ;increase start time and counter
iStart     +=         iDur
iThisNote  +=         1
 ;avoid continuous printing
iPrint     =          0
enduntil

 ;reset the duration of this instr to make all events happen
p3         =          iStart + 2

 ;increase index for sequence
giSeqIndx += 1
 ;call instr again if sequence has not been ended
 if giSeqIndx &lt; lenarray(giSequence) then
           event_i    "i", "notes", p3, 1, iHowMany
 ;or exit
           else
           event_i    "i", "exit", p3, 1
 endif
endin


;****INSTRUMENTS TO PLAY THE SOUNDS AND EXIT CSOUND****
instr play
 ;increase duration in random range
iDur       random     p3*2, p3*5
p3         =          iDur
 ;get frequency
iFreq      =          p4
 ;generate note with karplus-strong algorithm
aPluck     pluck      .2, iFreq, iFreq, 0, 1
aPluck     linen      aPluck, 0, p3, p3
 ;filter
aFilter    mode       aPluck, iFreq, .1
 ;mix aPluck and aFilter according to freq
 ;(high notes will be filtered more)
aMix       ntrpol     aPluck, aFilter, iFreq, 65, 65*16
 ;panning also according to freq
 ;(low = left, high = right)
iPan       =          (iFreq-65) / (65*16)
aL, aR     pan2       aMix, iPan
           outs       aL, aR
endin

instr exit
           exitnow
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i "notes" 0 1 23 ;set number of notes per instr here
e 99999 ;make possible to perform long (exit will be automatically)
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>
</p>
<h2>Random With History
  <br />
</h2>
<p>Many ways can be thought, and implemented, for the influence of the last step(s) on the current random choice. Two of them are used frequently. A Markov chain is based on a number of possible states, and defines a different probability for each of these states. A random walk looks at the last state as a position in a range or field, and allows only certain deviations from this position.
  <br />
</p>
<h3>Markov Chains
  <br />
</h3>
<p>A typical case for a Markov chain in music is the sequence of certain pitches or notes. For each note, the probability of the following note is written in a table like this:
</p>
<p><img src="static/01D_markov_table.png" height="185" width="274" />&nbsp;
</p>
<p>This means: the probability that element a is repeated, is 0.2; the probability that b follows a is 0.5; the probability that c follows a is 0.3. The sum of all probabilities must, by convention, add to 1. The following example shows the basic algorithm which evaluates the first line of the Markov table above, in the case, the previous element has been "a".
  <br />
</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 01D07_markov_basics.csd</strong></em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <br />
</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-ndm0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
0dbfs = 1
nchnls = 1
seed 0

instr 1
iLine[]    array      .2, .5, .3
iVal       random     0, 1
iAccum     =          iLine[0]
iIndex     =          0
 until iAccum &gt;= iVal do
iIndex     +=         1
iAccum     +=         iLine[iIndex]
 enduntil
           printf_i   "Random number = %.3f, next element = %c!\n", 1, iVal, iIndex+97
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
r 10
i 1 0 0
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz
</pre>
<p>The probabilities are 0.2 0.5 0.3. First, a uniformly distributed random number between 0 and 1 is generated. An acculumator is set to the first element of the line (here 0.2). It is asked whether it is larger than the random number. If so, the index is returned. If not, the second element is added (0.2+0.5=0.7), and the process is repeated, until the accumulator is greater or equal the random value. The output of the example should show something like this:
</p>
<p><font size="2"><font face="courier new,courier,monospace">Random number = 0.850, next element = c!
  <br />Random number = 0.010, next element = a!
  <br />Random number = 0.805, next element = c!
  <br />Random number = 0.696, next element = b!
  <br />Random number = 0.626, next element = b!
  <br />Random number = 0.476, next element = b!
  <br />Random number = 0.420, next element = b!
  <br />Random number = 0.627, next element = b!
  <br />Random number = 0.065, next element = a!
  <br />Random number = 0.782, next element = c!</font></font>
  <br />
</p>
<p>The next example puts this algorithm in an User Defined Opcode. Its input is a Markov table as a two-dimensional array, and the previous line as index (starting with 0). Its output is the next element, also as index. -- There are two Markov chains in this example: seven pitches, and three durations. Both are defined in two-dimensional arrays: <em>giProbNotes</em> and <em>giProbDurs</em>. Both Markov chains are running independently from each other.
</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 01D08_markov_music.csd</strong></em>
</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-dnm128 -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
0dbfs = 1
nchnls = 2
seed 0

;****USER DEFINED OPCODES FOR MARKOV CHAINS****
  opcode Markov, i, i[][]i
iMarkovTable[][], iPrevEl xin
iRandom    random     0, 1
iNextEl    =          0
iAccum     =          iMarkovTable[iPrevEl][iNextEl]
 until iAccum &gt;= iRandom do
iNextEl    +=         1
iAccum     +=         iMarkovTable[iPrevEl][iNextEl]
 enduntil
           xout       iNextEl
  endop
  opcode Markovk, k, k[][]k
kMarkovTable[][], kPrevEl xin
kRandom    random     0, 1
kNextEl    =          0
kAccum     =          kMarkovTable[kPrevEl][kNextEl]
 until kAccum &gt;= kRandom do
kNextEl    +=         1
kAccum     +=         kMarkovTable[kPrevEl][kNextEl]
 enduntil
           xout       kNextEl
  endop

;****DEFINITIONS FOR NOTES****
 ;notes as proportions and a base frequency
giNotes[]  array      1, 9/8, 6/5, 5/4, 4/3, 3/2, 5/3
giBasFreq  =          330
 ;probability of notes as markov matrix:
  ;first -&gt; only to third and fourth
  ;second -&gt; anywhere without self
  ;third -&gt; strong probability for repetitions
  ;fourth -&gt; idem
  ;fifth -&gt; anywhere without third and fourth
  ;sixth -&gt; mostly to seventh
  ;seventh -&gt; mostly to sixth
giProbNotes[][] init  7, 7
giProbNotes array     0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0,
                      0.2, 0.0, 0.2, 0.2, 0.2, 0.1, 0.1,
                      0.1, 0.1, 0.5, 0.1, 0.1, 0.1, 0.0,
                      0.0, 0.1, 0.1, 0.5, 0.1, 0.1, 0.1,
                      0.2, 0.2, 0.0, 0.0, 0.2, 0.2, 0.2,
                      0.1, 0.1, 0.0, 0.0, 0.1, 0.1, 0.6,
                      0.1, 0.1, 0.0, 0.0, 0.1, 0.6, 0.1

;****DEFINITIONS FOR DURATIONS****
 ;possible durations
gkDurs[]    array     1, 1/2, 1/3
 ;probability of durations as markov matrix:
  ;first -&gt; anything
  ;second -&gt; mostly self
  ;third -&gt; mostly second
gkProbDurs[][] init   3, 3
gkProbDurs array      1/3, 1/3, 1/3,
                      0.2, 0.6, 0.3,
                      0.1, 0.5, 0.4

;****SET FIRST NOTE AND DURATION FOR MARKOV PROCESS****
giPrevNote init       1
gkPrevDur  init       1

;****INSTRUMENT FOR DURATIONS****
  instr trigger_note
kTrig      metro      1/gkDurs[gkPrevDur]
 if kTrig == 1 then
           event      "i", "select_note", 0, 1
gkPrevDur  Markovk    gkProbDurs, gkPrevDur
 endif
  endin

;****INSTRUMENT FOR PITCHES****
  instr select_note
 ;choose next note according to markov matrix and previous note
 ;and write it to the global variable for (next) previous note
giPrevNote Markov     giProbNotes, giPrevNote
 ;call instr to play this note
           event_i    "i", "play_note", 0, 2, giPrevNote
 ;turn off this instrument
           turnoff
  endin

;****INSTRUMENT TO PERFORM ONE NOTE****
  instr play_note
 ;get note as index in ginotes array and calculate frequency
iNote      =          p4
iFreq      =          giBasFreq * giNotes[iNote]
 ;random choice for mode filter quality and panning
iQ         random     10, 200
iPan       random     0.1, .9
 ;generate tone and put out
aImp       mpulse     1, p3
aOut       mode       aImp, iFreq, iQ
aL, aR     pan2       aOut, iPan
           outs       aL, aR
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i "trigger_note" 0 100
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz&nbsp;
</pre>
<p>&nbsp;
</p>
<h3>Random Walk
</h3>
<p>In a way, "walk" is the opposite of "jump". If you jump between A and B, you get anywhere between these boundaries. But if you walk between A and B, you will have certain <em>steps</em>, and each step will apply a deviation to the previous one. If the deviation range is slightly more positive (say from -0.1 to +0.2), the overall results will get your walk more forward, in a "drunk" way. If the deviation range is more negative (say from -0.2 to 0.1), the walk will move more backwards as a whole.
</p>
<p>So one way for a random walk will be to get a previous state, apply a random deviation, and get the next state by adding this deviation to the previous state. The next example shows two ways of doing this.
</p>
<p>The <em>pitch</em> random walk starts at pitch 8 in octave notation. The general pitch deviation <em>gkPitchDev </em>is set to 0.2, so that the next pitch could be between 7.8 and 8.2. Bute there is also a pitch direction <em>gkPitchDir</em> which is set to 0.1 as initial value. This means that the upper limit of the next random pitch is 8.3 instead of 8.2, so that the pitch will move upwards in a larger number of steps. When the upper limit <em>giHighestPitch</em> has been crossed, the <em>gkPitchDir</em> variable changes from +0.1 to -0.1, so after some steps, the pitch will have become lower. Whenever such a direction change happens, the console reports this with a print.
</p>
<p>The <em>density</em> of the notes is defined as notes per second, and is applied as frequency to the <a href="http://www.csounds.com/manual/html/metro.html">metro</a> opcode in instrument "walk". The lowest possible density <em>giLowestDens</em> is set to 1, the highest to 8 notes per second, and the first density <em>giStartDens</em> is set to 3. The possible random deviation for the next density is defined in a range from zero to one: zero means no deviation at all, one means that the next density can alter the current density in a range from half the current value to twice the current value. For instance, if the current density is 4, for <em>gkDensDev=1</em> you would get a density between 2 and 8. The direction of the densities <em>gkDensDir</em> in this random walk follows the same range 0..1. Assumed you have no deviation of densities at all (<em>gkDensDev=0</em>), <em>gkDensDir=0</em> will produce ticks in always the same speed, whilst <em>gkDensDir=1</em> will produce a very rapid increase in speed. Similar to the pitch walk, the direction parameter changes from plus to minus if the upper border has crossed, and vice versa.
  <br />
</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 01D09_random_walk.csd</strong></em>
  <br />
</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-dnm128 -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
0dbfs = 1
nchnls = 2
seed 1 ;change to zero for always changing results

;****SETTINGS FOR PITCHES****
 ;define the pitch street in octave notation
giLowestPitch =     7
giHighestPitch =    9
 ;set pitch startpoint, deviation range and the first direction
giStartPitch =      8
gkPitchDev init     0.2 ;random range for next pitch
gkPitchDir init     0.1 ;positive = upwards

;****SETTINGS FOR DENSITY****
 ;define the maximum and minimum density (notes per second)
giLowestDens =      1
giHighestDens =     8
 ;set first density
giStartDens =       3
 ;set possible deviation in range 0..1
 ;0 = no deviation at all
 ;1 = possible deviation is between half and twice the current density
gkDensDev init      0.5
 ;set direction in the same range 0..1
 ;(positive = more dense, shorter notes)
gkDensDir init      0.1

;****INSTRUMENT FOR RANDOM WALK****
  instr walk
 ;set initial values
kPitch    init      giStartPitch
kDens     init      giStartDens
 ;trigger impulses according to density
kTrig     metro     kDens
 ;if the metro ticks
 if kTrig == 1 then
  ;1) play current note
          event     "i", "play", 0, 1.5/kDens, kPitch
  ;2) calculate next pitch
   ;define boundaries according to direction
kLowPchBound =      gkPitchDir &lt; 0 ? -gkPitchDev+gkPitchDir : -gkPitchDev
kHighPchBound =     gkPitchDir &gt; 0 ? gkPitchDev+gkPitchDir : gkPitchDev
   ;get random value in these boundaries
kPchRnd   random    kLowPchBound, kHighPchBound
   ;add to current pitch
kPitch += kPchRnd
  ;change direction if maxima are crossed, and report
  if kPitch &gt; giHighestPitch &amp;&amp; gkPitchDir &gt; 0 then
gkPitchDir =        -gkPitchDir
          printks   " Pitch touched maximum - now moving down.\n", 0
  elseif kPitch &lt; giLowestPitch &amp;&amp; gkPitchDir &lt; 0 then
gkPitchDir =        -gkPitchDir
          printks   "Pitch touched minimum - now moving up.\n", 0
  endif
  ;3) calculate next density (= metro frequency)
   ;define boundaries according to direction
kLowDensBound =     gkDensDir &lt; 0 ? -gkDensDev+gkDensDir : -gkDensDev
kHighDensBound =    gkDensDir &gt; 0 ? gkDensDev+gkDensDir : gkDensDev
   ;get random value in these boundaries
kDensRnd  random    kLowDensBound, kHighDensBound
   ;get multiplier (so that kDensRnd=1 yields to 2, and kDens=-1 to 1/2)
kDensMult =         2 ^ kDensRnd
   ;multiply with current duration
kDens *= kDensMult
   ;avoid too high values and too low values
kDens     =         kDens &gt; giHighestDens*1.5 ? giHighestDens*1.5 : kDens
kDens     =         kDens &lt; giLowestDens/1.5 ? giLowestDens/1.5 : kDens
   ;change direction if maxima are crossed
  if (kDens &gt; giHighestDens &amp;&amp; gkDensDir &gt; 0) || (kDens &lt; giLowestDens &amp;&amp; gkDensDir &lt; 0) then
gkDensDir =         -gkDensDir
   if kDens &gt; giHighestDens then
          printks   " Density touched upper border - now becoming less dense.\n", 0
          else
          printks   " Density touched lower border - now becoming more dense.\n", 0
   endif
  endif
 endif
  endin

;****INSTRUMENT TO PLAY ONE NOTE****
  instr play
 ;get note as octave and calculate frequency and panning
iOct       =          p4
iFreq      =          cpsoct(iOct)
iPan       ntrpol     0, 1, iOct, giLowestPitch, giHighestPitch
 ;calculate mode filter quality according to duration
iQ         ntrpol     10, 400, p3, .15, 1.5
 ;generate tone and throw out
aImp       mpulse     1, p3
aMode      mode       aImp, iFreq, iQ
aOut       linen      aMode, 0, p3, p3/4
aL, aR     pan2       aOut, iPan
           outs       aL, aR
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i "walk" 0 999
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz&nbsp;
</pre>
<h2>II. SOME MATH PERSPECTIVES ON RANDOM
  <br />
</h2>
<h3>Random Processes &nbsp;
</h3>
<p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times"><font class="Apple-style-span" face="verdana, arial, helvetica, sans-serif">The relative frequency of occurrence of a random variable can be described by a probability function (for discrete random variables) or by density functions (for continuous random variables).&nbsp;</font>
</p>
<p><font class="Apple-style-span" face="verdana, arial, helvetica, sans-serif"><span class="Apple-style-span" style="line-height: normal; ">When two dice are thrown simultaneously, the sum <em>x</em> of their numbers can be 2, 3, ...12. The following figure shows the probability function <em>p</em>(<em>x</em>) of these possible outcomes. <em>p</em>(<em>x</em>) is always less than or equal to 1. The sum of the probabilities of all possible outcomes is 1.&nbsp;</span>&nbsp;</font>&nbsp;
</p>
<p>&nbsp; &nbsp;&nbsp;<img src="static/random1.gif" />&nbsp;
</p>
<p><span class="Apple-style-span" style="line-height: normal; "><font class="Apple-style-span" face="verdana, arial, helvetica, sans-serif">For continuous random variables the probability of getting a specific value <em>x</em> is 0. But the probability of getting a value within a certain interval can be indicated by an area that corresponds to this probability. The function <em>f</em>(<em>x</em>) over these areas is called the density function. With the following density the chance of getting a number smaller than 0 is 0, to get a number between 0 and 0.5 is 0.5, to get a number between 0.5 and 1 is 0.5 etc. Density functions <em>f</em>(<em>x</em>) can reach values greater than 1 but the area under the function is 1.</font></span>
</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;<img src="static/random2.gif" />&nbsp;
</p>
<h4><span class="Apple-style-span" style="font-family: Helvetica; font-size: 14px; line-height: normal; "><strong>Generating Random Numbers With a Given Probability or Density&nbsp;</strong></span>&nbsp;
</h4>
<p><span class="Apple-style-span" style="line-height: normal; "><font class="Apple-style-span" face="verdana, arial, helvetica, sans-serif">Csound provides opcodes for some specific densities but no means to produce random number with user defined probability or density functions. The opcodes <em>rand_density</em> and <em>rand_probability </em>(see below) generate random numbers with probabilities or densities given by tables. They are realized by using the so-called <em>rejection sampling method</em>.</font></span>
</p>
<h4><font face="arial,helvetica,sans-serif"><span class="Apple-style-span" style="line-height: normal;"><strong>Rejection Sampling:&nbsp;</strong></span>&nbsp; </font>
</h4>
<p>
</p>
<p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times"><font class="Apple-style-span" face="verdana, arial, helvetica, sans-serif">The principle of <em>rejection sampling</em> is to first generate uniformly distributed random numbers in the range required and to then accept these values corresponding to a given density function (or otherwise </font><font class="Apple-style-span" face="verdana, arial, helvetica, sans-serif"><font class="Apple-style-span" face="verdana, arial, helvetica, sans-serif">to</font> reject them). Let us demonstrate this method using the density function shown in the next figure. (Since the rejection sampling method uses only the "shape" of the function, the area under the function need not be 1). We first generate uniformly distributed random numbers <em>rnd1</em> over the interval [0, 1]. Of these we accept a proportion corresponding to <em>f</em>(<em>rnd1</em>). For example, the value 0.32 will only be accepted in the proportion of <em>f</em>(0.32) = 0.82. We do this by generating a new random number <em>rand2</em> between 0 and 1 and accept <em>rnd1</em> only if <em>rand2</em> &lt; <em>f</em>(<em>rnd1</em>); otherwise we reject it. (see <em>Signals, Systems and Sound Synthesis</em> chapter 10.1.4.4)</font>
</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="static/random%203.gif" height="200" width="200" />
</p>
<p>
</p>
<p><span class="Apple-style-span" style="font-family: verdana, arial, helvetica, sans-serif; line-height: normal; "><em>rejection sampling</em></span>&nbsp;
</p>
<p>
</p>
<p>
</p>
<p><em><strong>EXAMPLE 01D10_Rejection_Sampling.csd</strong></em>
</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example by martin neukom
sr = 44100
ksmps = 10
nchnls = 1
0dbfs = 1

; random number generator to a given density function
; kout	random number; k_minimum,k_maximum,i_fn for a density function

opcode	rand_density, k, kki		

kmin,kmax,ifn	xin
loop:
krnd1		random		0,1
krnd2		random		0,1
k2		table		krnd1,ifn,1	
		if	krnd2 &gt; k2	kgoto loop			
		xout		kmin+krnd1*(kmax-kmin)
endop

; random number generator to a given probability function
; kout	random number
; in: i_nr number of possible values
; i_fn1 function for random values
; i_fn2 probability functionExponential: Generate a uniformly distributed number between 0 and 1 and take its natural logarithm.

opcode	rand_probability, k, iii		

inr,ifn1,ifn2	xin
loop:
krnd1		random		0,inr
krnd2		random		0,1
k2		table		int(krnd1),ifn2,0	
		if	krnd2 &gt; k2	kgoto loop	
kout		table		krnd1,ifn1,0		
		xout		kout
endop

instr 1

krnd		rand_density	400,800,2
aout		poscil		.1,krnd,1
		out		aout

endin

instr 2

krnd		rand_probability p4,p5,p6
aout		poscil		.1,krnd,1
		out		aout

endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;sine
f1 0 32768 10 1
;density function
f2 0 1024 6 1 112 0 800 0 112 1
;random values and their relative probability (two dice)
f3 0 16 -2 2 3 4 5 6 7 8 9 10 11 12
f4 0 16  2 1 2 3 4 5 6 5 4  3  2  1
;random values and their relative probability
f5 0 8 -2 400 500 600 800
f6 0 8  2 .3  .8  .3  .1

i1	0 10		

;i2 0 10 4 5 6
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>
</p>
<p>
</p>
<h4><span class="Apple-style-span" style="font-family: Helvetica; font-size: 14px; line-height: normal; "><strong>Random Walk</strong></span>&nbsp;
</h4>
<p><span class="Apple-style-span" style="line-height: normal; "><font class="Apple-style-span" face="verdana, arial, helvetica, sans-serif">In a series of random numbers the single numbers are independent upon each other. Parameter (left figure) or paths in the room (two-dimensional trajectory in the right figure) created by random numbers wildly jump around.</font></span>
</p>
<p><strong>Example 1&nbsp;</strong>
</p>
<p><font class="Apple-style-span" face="'courier new', courier, monospace"><strong><span class="Apple-style-span" style="line-height: normal; ">Table[RandomReal[{-1, 1}], {100}];</span>&nbsp;</strong></font>
</p>
<p><img src="static/random4a.gif" />&nbsp; &nbsp;<img src="static/random5a.gif" />&nbsp;
</p>
<p><font class="Apple-style-span" face="verdana, arial, helvetica, sans-serif"><span class="Apple-style-span" style="line-height: normal; ">We get a smoother path, a so-called random walk, by adding at every time step a random number <em>r</em> to the actual position <em>x</em> (<em>x </em>+= <em>r</em>)</span><span class="Apple-style-span" style="line-height: normal; ">.</span></font>
</p>
<p><strong>Example 2</strong>&nbsp;
</p>
<p><font class="Apple-style-span" face="'courier new', courier, monospace"><strong><span class="Apple-style-span" style="line-height: normal; ">x = 0; walk = Table[x += RandomReal[{-.2, .2}], {300}];</span>&nbsp;</strong></font>
</p>
<p><img src="static/random6a.gif" />&nbsp; &nbsp;<img src="static/random7a.gif" />
</p>
<p><span class="Apple-style-span" style="line-height: normal; "><font class="Apple-style-span" face="verdana, arial, helvetica, sans-serif">The path becomes even smoother by adding a random number <em>r</em> to the actual velocity <em>v</em>.</font></span>&nbsp;
</p>
<p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Courier"><strong>v += r</strong>
</p>
<p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Courier"><strong>x += v</strong>
</p>
<p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Courier; min-height: 14.0px"><strong></strong>
  <br />
</p>
<p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times"><font class="Apple-style-span" face="verdana, arial, helvetica, sans-serif">The path can by bounded to an area (figure to the right) by inverting the velocity if the path exceeds the limits (<em>min</em>, <em>max</em>):&nbsp;</font>
</p>
<p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; min-height: 14.0px">
  <br />
</p>
<p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Courier"><strong>vif(x &lt; min || x &gt; max) v *= -1</strong>
</p>
<p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Courier; min-height: 14.0px"><strong></strong>
  <br />
</p>
<p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times"><font class="Apple-style-span" face="verdana, arial, helvetica, sans-serif">The movement can be damped by decreasing the velocity at every time step by a small factor <em>d</em></font>
</p>
<p>&nbsp;<span class="Apple-style-span" style="font-family: Courier; line-height: normal; "><strong>v *= (1-d)</strong></span>&nbsp;
</p>
<p><strong>Example 3</strong>&nbsp;
</p>
<p><font class="Apple-style-span" face="'courier new', courier, monospace"><strong><span class="Apple-style-span" style="line-height: normal; ">x = 0; v = 0; walk = Table[x += v += RandomReal[{-.01, .01}], {300}];</span>&nbsp;</strong></font>
</p>
<p><img src="static/random8a.gif" />&nbsp; &nbsp;<img src="static/random9a.gif" />
</p>
<p>
</p>
<p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times"><font class="Apple-style-span" face="verdana, arial, helvetica, sans-serif">The path becomes again smoother by adding a random number <em>r</em> to the actual acelleration <em>a</em>, the change of the aceleration, etc.</font>
</p>
<p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; min-height: 14.0px">
  <br />
</p>
<p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Courier"><strong>a += r</strong>
</p>
<p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Courier"><strong>v += a</strong>
</p>
<p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Courier"><strong></strong><strong>x += v</strong>
</p>
<p><strong>Example 4</strong>&nbsp;
</p>
<p style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><font class="Apple-style-span" face="'courier new', courier, monospace"><strong>x = 0; v = 0; a = 0;&nbsp;
  <br /></strong></font>
</p>
<p><font class="Apple-style-span" face="'courier new', courier, monospace"><strong><span class="Apple-style-span" style="line-height: normal; ">Table[x += v += a += RandomReal[{-.0001, .0001}], {300}];</span>&nbsp;</strong></font>
</p>
<p><img src="static/random10a_1.gif" />&nbsp;&nbsp;<img src="static/random11a.gif" />
</p>
<p><font class="Apple-style-span" face="verdana, arial, helvetica, sans-serif">&nbsp;<span class="Apple-style-span" style="line-height: normal; ">(see Martin Neukom, <em>Signals, Systems and Sound Synthesis</em> chapter 10.2.3.2)</span></font>
</p>
<p><em><strong>EXAMPLE 01D11_Random_Walk2.csd</strong></em>
</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;example by martin neukom

sr = 44100
ksmps = 128
nchnls = 1
0dbfs = 1

; random frequency
instr 1

kx 	random 	-p6, p6
kfreq 	= 	p5*2^kx
aout 	oscil 	p4, kfreq, 1
out 	aout

endin

; random change of frequency
instr 2

kx 	init 	.5
kfreq 	= 	p5*2^kx
kv 	random 	-p6, p6
kv 	= 	kv*(1 - p7)
kx 	= 	kx + kv
aout 	oscil 	p4, kfreq, 1
out 	aout

endin

; random change of change of frequency
instr 3
kv	init	0
kx 	init 	.5
kfreq 	= 	p5*2^kx
ka 	random 	-p7, p7
kv 	= 	kv + ka
kv 	= 	kv*(1 - p8)
kx 	= 	kx + kv
kv 	= 	(kx &lt; -p6 || kx &gt; p6?-kv : kv)
aout 	oscili 	p4, kfreq, 1
out 	aout

endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;

f1 0 32768 10 1
; i1 	p4 	p5 	p6
; i2 	p4 	p5 	p6 	p7
; 	amp 	c_fr 	rand 	damp
; i2 0 20 	.1 	600 	0.01 	0.001
; 	amp 	c_fr 	d_fr 	rand 	damp
; 	amp 	c_fr 	rand
; i1 0 20 	.1 	600 	0.5
; i3 	p4 	p5 	p6 	p7 	p8
i3 0 20 	.1 	600 	1 	0.001 	0.001
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<h2>III. MISCELLANEOUS Examples
</h2>
<p>Csound has a range of opcodes and GEN routine for the creation of various random functions and distributions. Perhaps the simplest of these is <a href="http://www.csounds.com/manual/html/random.html">random</a> which simply generates a random value within user defined minimum and maximum limit and at i-time, k-rate or a-rate accroding to the variable type of its output:
</p>
<pre>ires random imin, imax
kres random kmin, kmax
ares random kmin, kmax
</pre>
<p> Values are generated according to a uniform random distribution, meaning that any value within the limits has equal chance of occurence. Non-uniform distributions in which certain values have greater chance of occurence over others are often more useful and musical. For these purposes, Csound includes the <a href="http://www.csounds.com/manual/html/betarand.html">betarand</a>, <a href="http://www.csounds.com/manual/html/bexprnd.html">bexprand</a>, <a href="http://www.csounds.com/manual/html/cauchy.html">cauchy</a>, <a href="http://www.csounds.com/manual/html/exprand.html">exprand</a>, <a href="http://www.csounds.com/manual/html/gauss.html">gauss</a>, <a href="http://www.csounds.com/manual/html/linrand.html">linrand</a>, <a href="http://www.csounds.com/manual/html/pcauchy.html">pcauchy</a>, <a href="http://www.csounds.com/manual/html/poisson.html">poisson</a>, <a href="http://www.csounds.com/manual/html/trirand.html">trirand</a>, <a href="http://www.csounds.com/manual/html/unirand.html">unirand</a> and <a href="http://www.csounds.com/manual/html/weibull.html">weibull</a> random number generator opcodes. The distributions generated by several of these opcodes are illustrated below.
</p>
<p><img src="static/linrand.png" />&nbsp;
</p>
<p>&nbsp;<img src="static/trirand.png" />
</p>
<p><img src="static/gauss.png" />
  <br />
</p>
<p><img src="static/exprand.png" />
  <br />
</p>
<p><img src="static/bexprand.png" />
  <br />
</p>
<p> <img src="static/betarand.png" />
</p>
<p>In addition to these so called 'x-class noise generators' Csound provides random function generators, providing values that change over time a various ways.
</p>
<p><a href="http://www.csounds.com/manual/html/randomh.html">randomh</a> generates new random numbers at a user defined rate. The previous value is held until a new value is generated, and then the output immediately assumes that value.
</p>
<p>The instruction:
</p>
<pre>kmin   =         -1
kmax   =         1
kfreq  =         2
kout&nbsp;&nbsp; randomh&nbsp;&nbsp; kmin,kmax,kfreq</pre>
<p>will produce and output something like:
</p>
<p><img src="static/randomh.png" height="151" width="568" />
  <br />
</p>
<p><a href="http://www.csounds.com/manual/html/randomi.html">randomi</a> is an interpolating version of randomh. Rather than jump to new values when they are generated, randomi interpolates linearly to the new value, reaching it just as a new random value is generated. Replacing randomh with randomi in the above code snippet would result in the following output:
</p>
<p><img src="static/randomi.png" height="164" width="567" />
</p>
<p>In practice randomi's angular changes in direction as new random values are generated might be audible depending on the how it is used. <a href="http://www.csounds.com/manual/html/rspline.html">rsplsine</a> allows us to specify not just a single frequency but a minimum and a maximum frequency, and the resulting function is a smooth spline between the minimum and maximum values and these minimum and maximum frequencies. The following input:
</p>
<pre>kmin     =         -0.95
kmax     =         0.95
kminfrq  =         1
kmaxfrq  =         4
asig     jspline   kmin, kmax, kminfrq, kmaxfrq
</pre>
<p>would generate an output something like:
</p>
<p><img src="static/rspline.png" height="144" width="565" />&nbsp;
</p>
<p>We need to be careful with what we do with rspline's output as it can exceed the limits set by kmin and kmax. Minimum and maximum values can be set conservatively or the <a href="http://www.csounds.com/manual/html/limit.html">limit</a> opcode could be used to prevent out of range values that could cause problems.
</p>
<p>The following example uses rspline to 'humanise' a simple synthesiser. A short melody is played, first without any humanising and then with humanising. rspline random variation is added to the amplitude and pitch of each note in addition to an i-time random offset.
  <br />
</p>
<p><em><strong>EXAMPLE 01D12_humanising.csd</strong></em>
</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1
seed 0

giWave  ftgen  0, 0, 2^10, 10, 1,0,1/4,0,1/16,0,1/64,0,1/256,0,1/1024

  instr 1 ; an instrument with no 'humanising'
inote =       p4
aEnv  linen   0.1,0.01,p3,0.01
aSig  poscil  aEnv,cpsmidinn(inote),giWave
      outs    aSig,aSig
  endin

  instr 2 ; an instrument with 'humanising'
inote   =       p4

; generate some i-time 'static' random paramters
iRndAmp random	-3,3   ; amp. will be offset by a random number of decibels
iRndNte random  -5,5   ; note will be offset by a random number of cents

; generate some k-rate random functions
kAmpWob rspline -1,1,1,10   ; amplitude 'wobble' (in decibels)
kNteWob rspline -5,5,0.3,10 ; note 'wobble' (in cents)

; calculate final note function (in CPS)
kcps    =        cpsmidinn(inote+(iRndNte*0.01)+(kNteWob*0.01))

; amplitude envelope (randomisation of attack time)
aEnv    linen   0.1*ampdb(iRndAmp+kAmpWob),0.01+rnd(0.03),p3,0.01
aSig    poscil  aEnv,kcps,giWave
        outs    aSig,aSig
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
t 0 80
#define SCORE(i) #
i $i 0 1   60
i .  + 2.5 69
i .  + 0.5 67
i .  + 0.5 65
i .  + 0.5 64
i .  + 3   62
i .  + 1   62
i .  + 2.5 70
i .  + 0.5 69
i .  + 0.5 67
i .  + 0.5 65
i .  + 3   64 #
$SCORE(1)  ; play melody without humanising
b 17
$SCORE(2)  ; play melody with humanising
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>The final example implements a simple algorithmic note generator. It makes use of GEN17 to generate histograms which define the probabilities of certain notes and certain rhythmic gaps occuring.
</p>
<p><em><strong>EXAMPLE 01D13_simple_algorithmic_note_generator.csd</strong></em>
</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac -dm0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

giNotes	ftgen	0,0,-100,-17,0,48, 15,53, 30,55, 40,60, 50,63, 60,65, 79,67, 85,70, 90,72, 96,75
giDurs	ftgen	0,0,-100,-17,0,2, 30,0.5, 75,1, 90,1.5

  instr 1
kDur  init        0.5             ; initial rhythmic duration
kTrig metro       2/kDur          ; metronome freq. 2 times inverse of duration
kNdx  trandom     kTrig,0,1       ; create a random index upon each metro 'click'
kDur  table       kNdx,giDurs,1   ; read a note duration value
      schedkwhen  kTrig,0,0,2,0,1 ; trigger a note!
  endin

  instr 2
iNote table     rnd(1),giNotes,1                 ; read a random value from the function table
aEnv  linsegr	0, 0.005, 1, p3-0.105, 1, 0.1, 0 ; amplitude envelope
iPlk  random	0.1, 0.3                         ; point at which to pluck the string
iDtn  random    -0.05, 0.05                      ; random detune
aSig  wgpluck2  0.98, 0.2, cpsmidinn(iNote+iDtn), iPlk, 0.06
      out       aSig * aEnv
  endin
&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0    300  ; start 3 long notes close after one another
i 1 0.01 300
i 1 0.02 300
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>
</p>
<p>
</p>
<p>
</p>
<p>
</p>
<ol id="InsertNote_NoteList">
  <li id="InsertNoteID_6">cf http://www.etymonline.com/index.php?term=random<span id="InsertNoteID_6_LinkBacks"><sup><a href="#InsertNoteID_6_marker7">^</a></sup></span></li>
  <li id="InsertNoteID_8">Because the sample rate is 44100 samples per second. So a repetition after 65536 samples will lead to a repetition after 65536/44100 = 1.486 seconds.<span id="InsertNoteID_8_LinkBacks"><sup><a href="#InsertNoteID_8_marker9">^</a></sup></span></li>
  <li id="InsertNoteID_22">Charles Dodge and Thomas A. Jerse, Computer Music, New York 1985, Chapter 8.1, in particular page 269-278.<span id="InsertNoteID_22_LinkBacks"><sup><a href="#InsertNoteID_22_marker23">^</a></sup></span></li>
  <li id="InsertNoteID_24">Most of them have been written by Paris Smaragdis in 1995: betarnd, bexprnd, cauchy, exprnd, gauss, linrand, pcauchy, poisson, trirand, unirand and weibull.<span id="InsertNoteID_24_LinkBacks"><sup><a href="#InsertNoteID_24_marker25">^</a></sup></span></li>
  <li id="InsertNoteID_7">According to Dodge/Jerse, the usual algorithms for exponential and gaussian are:
  <br />Exponential: Generate a uniformly distributed number between 0 and 1 and take its natural logarithm.
  <br />Gauss: Take the mean of uniformly distributed numbers and scale them by the standard deviation. <span id="InsertNoteID_7_LinkBacks"><sup><a href="#InsertNoteID_7_marker8">^</a></sup></span></li>
</ol>
   <hr/>
    <a href="/csound/_edit/">EDIT</a>

</div>

<script type="text/javascript">
jQuery(function ($) {
    $('#bookcontent').annotator()
   		.annotator('setupPlugins', {}, {
                Tags: false,
                Filter: {
                  addAnnotationFilter: false
                },
                Permissions: false,
                AnnotateItPermissions: {}
              });
});
</script>



</div>
<!-- End of content -->

</div>  
<!-- DEV TOOLS -->
<div id="bookidebug">
</div>

<!-- sputnik error page -->
<div id="dialog-sputnik-qrac" style="display: none"></div>
</body>
</html>

