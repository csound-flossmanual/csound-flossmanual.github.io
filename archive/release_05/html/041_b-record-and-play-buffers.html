
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> 
<html>
 <head>
   <link type="text/css" href="http://www.flossmanuals.net/_templates/prettify/src/prettify.css" rel="Stylesheet" />
   <script type="text/javascript" src="http://www.flossmanuals.net/_templates/prettify/src/prettify.js"></script>

   <link type="text/css" href="/site_static/js/jquery/themes/base/jquery.ui.all.css" rel="Stylesheet" >
   <link type="text/css" href="/site_static/js/jquery/themes/smoothness/jquery.ui.all.css" rel="Stylesheet" >
   <script type="text/javascript" src="/static/js/jquery-1.7.js"></script>
<!--
   <script type="text/javascript" src="/site_static/js/jquery/jquery-1.4.4.js"></script>
-->   
<script type="text/javascript" src="/site_static/js/jquery/ui/jquery-ui-1.8.10.custom.js"></script>
   <script type="text/javascript" src="/site_static/js/jquery.json-1.3.js"></script>
   <script type="text/javascript" src="/site_static/js/booki.js"></script>

   <link href="/site_static/css/jquery.bubblepopup.v2.3.1.css" rel="stylesheet" type="text/css" />
   <script src="/site_static/js/jquery.bubblepopup.v2.3.1.min.js" type="text/javascript"></script>

   <link type="text/css" href="/static/css/booki_fm.css" rel="Stylesheet"/ >
<style>
.template {
	display: none !important;
}


#header {
    background-color: transparent !important;
}
.paginator { padding:.5em .75em; float:left; font:normal .8em arial; }
 
.paginator .prev-na,
.paginator .next-na {
	padding:.3em;
	font-weight: bold;
/*	font:bold .875em arial; */
}
 
.paginator .prev-na,
.paginator .next-na {
/*	border:1px solid #ccc; 
	background-color:#f9f9f9; */
	color:#aaa;
	font-weight:normal;
}
 
.paginator .prev a, .paginator .prev a:visited,
.paginator .next a, .paginator .next a:visited {
/*	border:1px solid #c2ee62; 
	background-color:#edfdd0; */
	color:#234f32;
	padding:.3em;
/*	font:bold .875em arial; */
        font-weight: bold;
}
 
.paginator .prev, .paginator .prev-na { margin-right:.5em; }
.paginator .next, .paginator .next-na { margin-left:.5em; }
 
.paginator .page a, .paginator .page a:visited, .paginator .curr {
	padding:.25em;
	font-weight: normal;
/*	font:normal .875em verdana; */
/*	border:1px solid #C2EE62; 
	background-color:#EDFDD0; */
	margin:0em .25em;	
	color:#006000;
}
 
.paginator .curr { 
/*	background-color:#234f32; 
	color:#fff; */
	border:1px solid #234f32; 
	font-weight:bold;
	font-size:1em;
}
 
.paginator .page a:hover,
.paginator .curr a:hover,
.paginator .prev a:hover,
.paginator .next a:hover {
/*	color:#fff;
	background-color:#234f32;
	border:1px solid #234f32; */
}
</style>
 <script type="text/javascript">
      $(function() {
   $.booki.sputnikDispatcherURL = "/_sputnik/";
    });
   </script>

   <script type="text/javascript">
     $(function() {
	 // open debug window
	 $.booki.debug.init();
	 
	 
	 $("A.debug").click(function() {
	     $("#bookidebug").dialog("open");
	     return false;
	 });
     });
   </script>

   
<title>/chapter: B-Record-And-Play-Buffers / CSound</title>
<link type="text/css" href="/site_static/css/editor.css" rel="Stylesheet" />

<script src="http://assets.annotateit.org/annotator/v1.2.5/annotator-full.min.js"></script>
<link rel="stylesheet" href="http://assets.annotateit.org/annotator/v1.2.5/annotator.min.css">



<link rel="alternate" type="application/rss+xml" title="RSS feed for CSound" href="/feeds/rss/book/csound/" /> 
<link rel="alternate" type="application/atom+xml" title="Atom feed for CSound" href="/feeds/atom/book/csound/" /> 

<link rel="alternate" type="application/rss+xml" title="RSS feed for chapter B-Record-And-Play-Buffers" href="/feeds/rss/chapter/csound/csound/" /> 
<link rel="alternate" type="application/atom+xml" title="Atom feed for chapter B-Record-And-Play-Buffers" href="/feeds/atom/chapter/csound/csound/" /> 


 </head>
<body onload="prettyPrint()" >
<!-- testis -->

<script type="text/javascript">
$(function() {
    $("#snippetdialog").dialog({autoOpen: false});
});
</script>


<div id="snippetdialog" title="Basic dialog">
        <p></p>
</div>



<div id="page-container"> 
<style>
body
{
margin:0;
padding:0
}
#header
{
position:absolute;
top:23px;
width:100%;
background-image: url('http://www.flossmanuals.net/_templates/fm_resources/header_bg.gif');
background-position: 700px 0px; /* this places the orange background at
an offset, making sure it doesn't underlap the left side of the gif */
background-repeat: no-repeat;
}

#fmheader {
    background-image: url("http://en.flossmanuals.net/_templates/fm_resources/header_bg.gif");
    background-position: 600px 0;
    background-repeat: no-repeat;
    position: absolute;
    top: 23px;
    width: 100%;
}
#header_image
{
margin-left: 270px;
border: 0px
}

#navigation
{
position:absolute;
top: 80px;
left: 357px;
width:50%;
}


#languages
{
position:absolute;
top: 40px;
left: 740px;
width:50%;
}
</style>



<!-- Header graphic is common to all pages  -->
<div id="header"><img id="header_image" alt="FlossManuals menu" src="http://www.flossmanuals.net/_templates/fm_resources/header_menu.gif" height="95" width="465" border="0"></div>


<!-- Navigation buttons are language and context specific  -->
<div id="navigation">
<a title="Read" href="http://en.flossmanuals.net/index.php"><img src="http://www.flossmanuals.net/_templates/fm_resources/read_en.png" width="65" height="30" border="0" alt="Read"></a>
<a title="Write" href="http://booki.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/write_active_en.png" width="65" height="30" border="0" alt="Write"></a>
<a title="Remix" href="http://en.flossmanuals.net/index.php?plugin=remix"><img src="http://www.flossmanuals.net/_templates/fm_resources/remix_en.png" width="65" height="30" border="0" alt="Remix"></a>
<a title="About" href="http://www.flossmanuals.org"><img src="http://www.flossmanuals.net/_templates/fm_resources/about_en.png" width="65" height="30" border="0" alt="About"></a>
</div>

<!-- Language buttons are common to all pages  -->
<div id="languages">
<a title="English" href="http://en.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/english_button.png" width="65" height="30" border="0" alt="English"></a>

<!-- <a title="Español" href="http://es.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/spanish_button.png" width="65" height="30" border="0" alt="Español"></a> -->
<a title="فارسی" href="http://fa.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/farsi_button.png" width="65" height="30" border="0" alt="فارسی"></a>
<a title="Suomi" href="http://fi.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/finnish_button.png" width="65" height="30" border="0" alt="Suomi"></a>
<br>
<a title="Français" href="http://fr.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/french_button.png" width="65" height="30" border="0" alt="Français"></a>
<a title="Nederlands" href="http://nl.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/dutch_button.png" width="65" height="30" border="0" alt="Nederlands"></a>
<!-- <a title="Pусский" href="http://ru.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/russian_button.png" width="65" height="30" border="0" alt="Pусский"></a> -->
<a title="Translate" href="http://translate.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/translate_button.png" width="65" height="30" border="0" alt="Translate"></a>
</div>

<!-- End top bar -->

<!-- nav box + drop shadow -->
<div class="navbox shadow" style="top:160px;">
    		<ul>

 		<li><a href="/accounts/signin/?redirect=/csound/_draft/_v/1.0/b-record-and-play-buffers/">Sign In</li><li>Register</a></li>

                <li><a href="/list-books">All Manuals</a></li>
                <li><a href="/list-groups">All Groups</a></li>
                <li><a href="/list-people/">All People</a></li>
           	</ul>
</div>
<!-- End of nav box -->



<div class="content-container shadow">
<!-- Content box and the drop shadow-->




<br clear="all"/>
   <h1>CSound</h1>


<div id="bookmenu"   style="background: url(/site_static/images/draft_bg.png) repeat !important;">
<ul>

 
   <li><b>INTRODUCTION</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/introduction/">PREFACE</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/how-to-use-this-manual/">HOW TO USE THIS MANUAL</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/on-this-release/">ON THIS RELEASE</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/credits/">CREDITS</a></li>
 

 
   <li><b>01 BASICS</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-digital-audio/">A. DIGITAL AUDIO</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-pitch-and-frequency/">B. PITCH AND FREQUENCY</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-intensities/">C. INTENSITIES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/random/">D. RANDOM</a></li>
 

 
   <li><b>02 QUICK START</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-make-csound-run/">A. MAKE CSOUND RUN</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-csound-syntax/">B. CSOUND SYNTAX</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-configuring-midi/">C. CONFIGURING MIDI</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-live-audio/">D. LIVE AUDIO</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/e-rendering-to-file/">E. RENDERING TO FILE</a></li>
 

 
   <li><b>03 CSOUND LANGUAGE</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-initialization-and-performance-pass/">A. INITIALIZATION AND PERFORMANCE PASS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-local-and-global-variables/">B. LOCAL AND GLOBAL VARIABLES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-control-structures/">C. CONTROL STRUCTURES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-function-tables/">D. FUNCTION TABLES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/arrays/">E. ARRAYS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/e-triggering-instrument-events/">F. LIVE EVENTS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/f-user-defined-opcodes/">G. USER DEFINED OPCODES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/macros/">H. MACROS</a></li>
 

 
   <li><b>04 SOUND SYNTHESIS</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-additive-synthesis/">A. ADDITIVE SYNTHESIS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-subtractive-synthesis/">B. SUBTRACTIVE SYNTHESIS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-amplitude-and-ringmodulation/">C. AMPLITUDE AND RING MODULATION</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-frequency-modulation/">D. FREQUENCY MODULATION</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/e-waveshaping/">E. WAVESHAPING</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/f-granular-synthesis/">F. GRANULAR SYNTHESIS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/g-physical-modelling/">G. PHYSICAL MODELLING</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/scanned-synthesis/">H. SCANNED SYNTHESIS</a></li>
 

 
   <li><b>05 SOUND MODIFICATION</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-envelopes/">A. ENVELOPES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-panning-and-spatialization/">B. PANNING AND SPATIALIZATION</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-filters/">C. FILTERS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-delay-and-feedback/">D. DELAY AND FEEDBACK</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/e-reverberation/">E. REVERBERATION</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/f-am-rm-waveshaping/">F. AM / RM / WAVESHAPING</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/g-granular-synthesis/">G. GRANULAR SYNTHESIS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/h-convolution/">H. CONVOLUTION</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/i-fourier-analysis-spectral-processing/">I. FOURIER ANALYSIS / SPECTRAL PROCESSING</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/k-ats-resynthesis/">K. ATS RESYNTHESIS</a></li>
 

 
   <li><b>06 SAMPLES</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-record-and-play-soundfiles/">A. RECORD AND PLAY SOUNDFILES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-record-and-play-buffers/">B. RECORD AND PLAY BUFFERS</a></li>
 

 
   <li><b>07 MIDI</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-receiving-events-by-midiin/">A. RECEIVING EVENTS BY MIDIIN</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-triggering-instrument-instances/">B. TRIGGERING INSTRUMENT INSTANCES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-working-with-controllers/">C. WORKING WITH CONTROLLERS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-reading-midi-files/">D. READING MIDI FILES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/e-midi-output/">E. MIDI OUTPUT</a></li>
 

 
   <li><b>08 OTHER COMMUNICATION</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/osc-and-wii/">A. OPEN SOUND CONTROL</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/csound-in-arduino/">B. CSOUND AND ARDUINO</a></li>
 

 
   <li><b>09 CSOUND IN OTHER APPLICATIONS</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/csound-in-pd/">A. CSOUND IN PD</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/csound-in-maxmsp/">B. CSOUND IN MAXMSP</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/csound-in-ableton-live/">C. CSOUND IN ABLETON LIVE</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-csound-as-a-vst-plugin/">D. CSOUND AS A VST PLUGIN</a></li>
 

 
   <li><b>10 CSOUND FRONTENDS</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/qutecsound/">CSOUNDQT</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/cecilia/">CABBAGE</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/blue/">BLUE</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/winxound/">WINXOUND</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/csound-via-terminal/">CSOUND VIA TERMINAL</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/web-based-csound/">WEB BASED CSOUND</a></li>
 

 
   <li><b>11 CSOUND UTILITIES</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/csound-utilities/">CSOUND UTILITIES</a></li>
 

 
   <li><b>12 CSOUND AND OTHER PROGRAMMING LANGUAGES</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/the-csound-api/">A. THE CSOUND API</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/using-python-inside-csound/">B. PYTHON INSIDE CSOUND</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-python-in-csoundqt/">C. PYTHON IN CSOUNDQT</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-lua-in-csound/">D. LUA IN CSOUND</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/e-csound-in-ios/">E. CSOUND IN iOS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/f-csound-on-android/">F. CSOUND ON ANDROID</a></li>
 

 
   <li><b>13 EXTENDING CSOUND</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/extending-csound/">EXTENDING CSOUND</a></li>
 

 
   <li><b>OPCODE GUIDE</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/overview/">OVERVIEW</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/signal-processing-i/">SIGNAL PROCESSING I</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/signal-processing-ii/">SIGNAL PROCESSING II</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/data/">DATA</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/realtime-interaction/">REALTIME INTERACTION</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/instrument-control/">INSTRUMENT CONTROL</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/math-pythonsystem-plugins/">MATHS, PYTHON/SYSTEM, PLUGINS</a></li>
 

 
   <li><b>APPENDIX</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/writing-csound-scores-by-hand/">METHODS OF WRITING CSOUND SCORES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/glossary/">GLOSSARY</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/links/">LINKS</a></li>
 

</ul>
</div>
<div id="bookcontent"   >
<title>Csound: RECORDANDPLAYBUFFERS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<h1>RECORD AND PLAY BUFFERS
</h1>
<h2>Playing Audio From RAM - flooper2
</h2>
<p>
</p>
<p class="western"><span>Csound offers many opcodes for playing back sound files that have first been loaded into a function table (and therefore are loaded into RAM). Some of these offer higher quality at the expense of computation speed some are simpler and less fully featured.</span>
</p>
<p class="western"><span>One of the newer and easier to use opcodes for this task is </span><a href="http://www.csounds.com/manual/html/flooper2.html"><span>flooper2</span></a><em></em><span>. As its name might suggest it is intended for the playback of files with looping. </span><span>'flooper2'</span><em> </em><span>can also apply a cross-fade between the end and the beginning of the loop in order to smooth the transition where looping takes place.</span>
</p>
<p><span>In the following example a sound file that has been loaded into a GEN01 function table is played back using </span><span>'flooper2</span><span>'. </span><span>'flooper2'</span><span> also includes a parameter for modulating playback speed/pitch</span><em>.</em><span> There is also the option of modulating the loop points at k-rate. In this example the entire file is simply played and looped. You can replace the sound file with one of your own or you can download the one used in the example from <a href="www.iainmccurdy.org/csoundrealtimeexamples/sourcematerials/loop.wav">here</a>:</span>
  <br />
</p>
<h3>Some notes about GEN01 and function table sizes:
</h3>
<p>When storing sound files in GEN01 function tables we must ensure that we define a table of sufficient size to store our sound file. Normally function table sizes should be powers of 2 (2, 4, 8, 16, 32 etc.). If we know the duration of our sound file we can derive the required table size by multiplying this duration by the sample rate and then choosing the next power of 2 larger than this. For example when the sampling rate is 44100, we will require 44100 table locations to store 1 second of audio; but 44100 is not a power of 2 so we must choose the next power of 2 larger than this which is 65536. (Hint: you can discover a sound file's duration by using Csound's 'sndinfo' utility.)
  <br />
</p>
<p>There are some 'lazy' options however: if we underestimate the table size, when we then run Csound it will warn us that this table size is too small and conveniently inform us via the terminal what the minimum size required to store the entire file would be - we can then substitute this value in our GEN01 table. We can also overestimate the table size in which case Csound won't complain at all, but this is a rather inefficient approach.
</p>
<p>If we give table size a value of zero we have what is referred to as 'deferred table size'. This means that Csound will calculate the exact table size needed to store our sound file and use this as the table size but this will probably not be a power of 2. Many of Csound's opcodes will work quite happily with non-power of 2 function table sizes, but not all! It is a good idea to know how to deal with power of 2 table sizes. We can also explicitly define non-power of 2 table sizes by prefacing the table size with a minus sign '-'.
  <br />
</p>
<p>All of the above discussion about required table sizes assumed that the sound file was mono, to store a stereo sound file will naturally require twice the storage space, for example, 1 second of stereo audio will require 88200 storage locations. GEN01 will indeed store stereo sound files and many of Csound's opcodes will read from stereo GEN01 function tables, but again not all! We must be prepared to split stereo sound files, either to two sound files on disk or into two function tables using GEN01's 'channel' parameter (p8), depending on the opcodes we are using.
</p>
<p>Storing audio in GEN01 tables as mono channels with non-deferred and power of 2 table sizes will ensure maximum compatibility.
  <br />
</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 06B01_flooper2.csd</strong></em>&nbsp;&nbsp;
</p>
<pre>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activate real-time audio
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; example written by Iain McCurdy

sr 	= 	44100
ksmps 	= 	32
nchnls 	= 	1	
0dbfs   =       1

; STORE AUDIO IN RAM USING GEN01 FUNCTION TABLE
giSoundFile   ftgen   0, 0, 262144, 1, "loop.wav", 0, 0, 0

  instr	1 ; play audio from function table using flooper2 opcode
kAmp         =         1   ; amplitude
kPitch       =         p4  ; pitch/speed
kLoopStart   =         0   ; point where looping begins (in seconds)
kLoopEnd     =         nsamp(giSoundFile)/sr; loop end (end of file)
kCrossFade   =         0   ; cross-fade time
; read audio from the function table using the flooper2 opcode
aSig         flooper2  kAmp,kPitch,kLoopStart,kLoopEnd,kCrossFade,giSoundFile
             out       aSig ; send audio to output
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; p4 = pitch
; (sound file duration is 4.224)
i 1 0 [4.224*2] 1
i 1 + [4.224*2] 0.5
i 1 + [4.224*1] 2
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</pre>
<p>
</p>
<h2> Csound's Built-in Record-Play Buffer - sndloop
</h2>
<p>
</p>
<p class="western">Csound has an opcode called <a href="http://www.csounds.com/manual/html/sndloop.html">sndloop</a> which provides a simple method of recording some audio into a buffer and then playing it back immediately. The duration of audio storage required is defined when the opcode is initialized. In the following example two seconds is provided. Once activated, as soon as two seconds of live audio has been recorded by 'sndloop', it<em></em> immediately begins playing it back in a loop. 'sndloop'<em> </em><span>allows us to modulate the speed/pitch of the played back audio as well as providing the option of defining a crossfade time between the end and the beginning of the loop. </span>In the example pressing 'r' on the computer keyboard activates record followed by looped playback, pressing 's' stops record or playback, pressing '+' increases the speed and therefore the pitch of playback and pressing '-' decreases the speed/pitch of playback. If playback speed is reduced below zero it enters the negative domain in which case playback will be reversed.
</p>
<p class="western">You will need to have a microphone connected to your computer in order to use this example.
  <br />
</p>
<p class="western"> &nbsp;&nbsp; <em><strong>EXAMPLE 06B02_sndloop.csd</strong></em>&nbsp;&nbsp;
</p>
<p>
</p>
<pre>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
; real-time audio in and out are both activated
-iadc -odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;example written by Iain McCurdy

sr 	= 	44100
ksmps 	= 	32
nchnls 	= 	1	

  instr	1
; PRINT INSTRUCTIONS
           prints  "Press 'r' to record, 's' to stop playback, "
           prints  "'+' to increase pitch, '-' to decrease pitch.\\n"
; SENSE KEYBOARD ACTIVITY
kKey sensekey; sense activity on the computer keyboard
aIn        inch    1             ; read audio from first input channel
kPitch     init    1             ; initialize pitch parameter
iDur       init    2             ; inititialize duration of loop parameter
iFade      init    0.05          ; initialize crossfade time parameter
 if kKey = 114 then              ; if 'r' has been pressed...
kTrig      =       1             ; set trigger to begin record-playback
 elseif kKey = 115 then          ; if 's' has been pressed...
kTrig      =       0             ; set trigger to turn off record-playback
 elseif kKey = 43 then           ; if '+' has been pressed...
kPitch     =       kPitch + 0.02 ; increment pitch parameter
 elseif kKey = 95 then           ; if '-' has been pressed
kPitch     =       kPitch - 0.02 ; decrement pitch parameter
 endif                           ; end of conditional branches
; CREATE SNDLOOP INSTANCE
aOut, kRec sndloop aIn, kPitch, kTrig, iDur, iFade ; (kRec output is not used)
           out     aOut          ; send audio to output
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 3600 ; instr 1 plays for 1 hour
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</pre>
<h2>Recording to and Playback from a Function Table
</h2>
<p>
</p>
<p class="western">Writing to and reading from buffers can also be achieved through the use of Csound's opcodes for table reading and writing operations. Although the procedure is a little more complicated than that required for 'sndloop'<span> it is ultimately more flexible. In the next example separate instruments are used for recording to the table and for playing back from the table. Another instrument which runs constantly scans for activity on the computer keyboard and activates the record or playback instruments accordingly. For writing to the table we will use the </span><a href="http://www.csounds.com/manual/html/tablew.html">tablew</a><span> opcode and for reading from the table we will use the <a href="http://www.csounds.com/manual/html/table.html">table</a></span><span> opcode (if we were to modulate the playback speed it would be better to use one of Csound's interpolating variations of '</span>table<span>' such as </span><a href="http://www.csounds.com/manual/html/tablei.html">tablei</a><span> or </span><a href="http://www.csounds.com/manual/html/table3.html">table3</a><span>. Csound writes individual values to table locations, the exact table locations being defined by an 'index'</span><em></em><span>. For writing continuous audio to a table this index will need to be continuously moving 1 location for every sample. This moving index (or 'pointer') can be created with an a-rate <a href="http://www.csounds.com/manual/html/line.html">line</a> or a <a href="http://www.csounds.com/manual/html/phasor.html">phasor</a>. The next example uses 'line'</span><span>. When using Csound's table operation opcodes we first need to create that table, either in the orchestra header or in the score. The duration of the audio buffer can be calculated from the size of the table. In this example the table is 2^17 points long, that is 131072 points. The duration in seconds is this number divided by the sample rate which in our example is 44100Hz. Therefore maximum storage duration for this example is 131072/44100 which is around 2.9 seconds.</span>
</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 06B03_RecPlayToTable.csd</strong></em>&nbsp;&nbsp; &nbsp;
</p>
<p>
</p>
<pre>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
; real-time audio in and out are both activated
-iadc -odac -d -m0
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; example written by Iain McCurdy

sr 	= 	44100
ksmps 	= 	32
nchnls 	= 	1

giBuffer ftgen  0, 0, 2^17, 7, 0; table for audio data storage
maxalloc 2,1 ; allow only one instance of the recording instrument at a time!

  instr	1 ; Sense keyboard activity. Trigger record or playback accordingly.
           prints  "Press 'r' to record, 'p' for playback.\\n"
iTableLen  =       ftlen(giBuffer)  ; derive buffer function table length
idur       =       iTableLen / sr   ; derive storage time in seconds
kKey sensekey                       ; sense activity on the computer keyboard
  if kKey=114 then                  ; if ASCCI value of 114 ('r') is output
event	"i", 2, 0, idur, iTableLen  ; activate recording instrument (2)
  endif
 if kKey=112 then                   ; if ASCCI value of 112 ('p) is output
event	"i", 3, 0, idur, iTableLen  ; activate playback instrument
 endif
  endin

  instr 2 ; record to buffer
iTableLen  =        p4              ; table/recording length in samples
; -- print progress information to terminal --
           prints   "recording"
           printks  ".", 0.25       ; print '.' every quarter of a second
krelease   release                  ; sense when note is in final k-rate pass...
 if krelease=1 then                 ; then ..
           printks  "\\ndone\\n", 0 ; ... print a message
 endif
; -- write audio to table --
ain        inch     1               ; read audio from live input channel 1
andx       line     0,p3,iTableLen  ; create an index for writing to table
           tablew   ain,andx,giBuffer ; write audio to function table
endin

  instr 3 ; playback from buffer
iTableLen  =        p4              ; table/recording length in samples
; -- print progress information to terminal --
           prints   "playback"
           printks  ".", 0.25       ; print '.' every quarter of a second
krelease   release                  ; sense when note is in final k-rate pass
 if krelease=1 then                 ; then ...
           printks  "\\ndone\\n", 0 ; ... print a message
 endif; end of conditional branch
; -- read audio from table --
aNdx       line     0, p3, iTableLen; create an index for reading from table
a1         table    aNdx, giBuffer  ; read audio to audio storage table
           out      a1              ; send audio to output
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 3600 ; Sense keyboard activity. Start recording - playback.
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;
</pre>
<h2>Encapsulating Record and Play Buffer Functionality to a UDO
</h2>
<p>Recording and playing back of buffers can also be encapsulated into a User Defined Opcode. This time the <em>tabw</em> opcode will be used for writing audio data to a buffer. <em>tabw</em> is slightly faster than <a href="http://www.csounds.com/manual/html/tablew.html">tablew</a> but doesn't offer the same number of protections for out of range index values.
  <br />An empty table (buffer) of any size can be created with a negative number as size. A table for recording 10 seconds of audio data can be created in this way:
  <br />
</p>
<pre>giBuf1&nbsp;&nbsp;&nbsp; ftgen&nbsp;&nbsp;&nbsp; 0, 0, -(10*sr), 2, 0
</pre>
<p>The user can decide whether they want to assign a certain number to the table, or whether to allow Csound do assign one automatically, thereafter calling the table via its variable name, in this case giBuf1. Below follows a UDO for creating a mono buffer, and another UDO for creating a stereo buffer:
  <br />
</p>
<pre> opcode BufCrt1, i, io
ilen, inum xin
ift&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftgen&nbsp;&nbsp;&nbsp;&nbsp; inum, 0, -(ilen*sr), 2, 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ift
&nbsp;endop

&nbsp;opcode BufCrt2, ii, io
ilen, inum xin
iftL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftgen&nbsp;&nbsp;&nbsp;&nbsp; inum, 0, -(ilen*sr), 2, 0
iftR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftgen&nbsp;&nbsp;&nbsp;&nbsp; inum, 0, -(ilen*sr), 2, 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iftL, iftR
&nbsp;endop&nbsp;
</pre>
<p>This simplifies the procedure of creating a record/play buffer, because the user is just asked for the length of the buffer. A number can be given, but by default Csound will assign this number. This statement will create an empty stereo table for 5 seconds of recording:
  <br />
</p>
<pre>iBufL,iBufR BufCrt2&nbsp;&nbsp; 5
</pre>
<p>A first, simple version of a UDO for recording will just write the incoming audio to sequential locations of the table. This can be done by setting the <em>ksmps</em> value to 1 inside this UDO (setksmps 1), so that each audio sample has its own discrete k-value. In this way the write index for the table can be assigned via the statement andx=kndx, and increased by one for the next k-cycle. An additional k-input turns recording on and off:
  <br />
</p>
<pre> opcode BufRec1, 0, aik
ain, ift, krec&nbsp; xin
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setksmps&nbsp; 1
if krec == 1 then ;record as long as krec=1
kndx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
andx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kndx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tabw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ain, andx, ift
kndx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kndx+1
endif
&nbsp;endop
</pre>
<p>The reading procedure is just as simple. In fact the same code can be used; it will be sufficient just to replace the opcode for writing (<em>tabw</em>) with the opcode for reading (<em>tab</em>):
  <br />
</p>
<pre> opcode BufPlay1, a, ik
ift, kplay&nbsp; xin
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setksmps&nbsp; 1
if kplay == 1 then ;play as long as kplay=1
kndx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
andx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kndx
aout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tab&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; andx, ift
kndx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kndx+1
endif
&nbsp;endop
</pre>
<p>Next we will use these first simple UDOs in a Csound instrument. Press the "r" key as long as you want to record, and the "p" key for playing back. Note that you must disable the key repeats on your computer keyboard for this example (in QuteCsound, disable "Allow key repeats" in Configuration -&gt; General).
  <br />
</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 06B04_BufRecPlay_UDO.csd</strong></em>&nbsp;
  <br />
</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-i adc -o dac -d -m0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example written by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

  opcode BufCrt1, i, io
ilen, inum xin
ift       ftgen     inum, 0, -(ilen*sr), 2, 0
          xout      ift
  endop

  opcode BufRec1, 0, aik
ain, ift, krec  xin
          setksmps  1
imaxindx  =         ftlen(ift)-1 ;max index to write
knew      changed   krec
if krec == 1 then ;record as long as krec=1
 if knew == 1 then ;reset index if restarted
kndx      =         0
 endif
kndx      =         (kndx &gt; imaxindx ? imaxindx : kndx)
andx      =         kndx
          tabw      ain, andx, ift
kndx      =         kndx+1
endif
  endop

  opcode BufPlay1, a, ik
ift, kplay  xin
          setksmps  1
imaxindx  =         ftlen(ift)-1 ;max index to read
knew      changed   kplay
if kplay == 1 then ;play as long as kplay=1
 if knew == 1 then ;reset index if restarted
kndx      =         0
 endif
kndx      =         (kndx &gt; imaxindx ? imaxindx : kndx)
andx      =         kndx
aout      tab       andx, ift
kndx      =         kndx+1
endif
          xout      aout
  endop

  opcode KeyStay, k, kkk
;returns 1 as long as a certain key is pressed
key, k0, kascii    xin ;ascii code of the key (e.g. 32 for space)
kprev     init      0 ;previous key value
kout      =         (key == kascii || (key == -1 &amp;&amp; kprev == kascii) ? 1 : 0)
kprev     =         (key &gt; 0 ? key : kprev)
kprev     =         (kprev == key &amp;&amp; k0 == 0 ? 0 : kprev)
          xout      kout
  endop

  opcode KeyStay2, kk, kk
;combines two KeyStay UDO's (this way is necessary
;because just one sensekey opcode is possible in an orchestra)
kasci1, kasci2 xin ;two ascii codes as input
key,k0    sensekey
kout1     KeyStay   key, k0, kasci1
kout2     KeyStay   key, k0, kasci2
          xout      kout1, kout2
  endop


instr 1
ain        inch      1 ;audio input on channel 1
iBuf       BufCrt1   3 ;buffer for 3 seconds of recording
kRec,kPlay KeyStay2  114, 112 ;define keys for record and play
           BufRec1   ain, iBuf, kRec ;record if kRec=1
aout       BufPlay1  iBuf, kPlay ;play if kPlay=1
           out       aout ;send out
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1000
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p> Next we will create an extended and easier to use version of these two UDOs for recording and playing back a buffer. The requirements of a user might be the following:
</p>
<p><strong>Recording:</strong>
  <br />
</p>
<ul>
  <li>allow recording not just from the beginning of the buffer, but also from any arbitrary starting point <em>kstart</em>
  <br /></li>
  <li>allow circular recording (wrap around) if the end of the buffer has been reached: <em>kwrap=1</em>
  <br /></li>
</ul>
<p> <strong>Playing:</strong>
</p>
<ul>
  <li>play back with different speed <em>kspeed</em> (negative speed means playing backwards)
  <br /></li>
  <li>start playback at any point of the buffer <em>kstart</em>
  <br /></li>
  <li>end playback at any point of the buffer <em>kend</em>
  <br /></li>
  <li>allow certain modes of wraparound <em>kwrap </em>while playing:</li>
</ul>
<blockquote>
</blockquote>
<ul>
  <ul>
    <li>kwrap=0 stops at the defined end point of the buffer</li>
    <li>kwrap=1 repeats playback between defined end and start points</li>
    <li>kwrap=2 starts at a defined starting point but wraps between end point and beginning of the buffer</li>
    <li>kwrap=3 wraps between <em>kstart</em> and the end of the table</li>
  </ul>
</ul>
<p>The following example provides versions of <em>BufRec</em> and <em>BufPlay</em> which do this job. We will use the table3 opcode instead of the simple tab or table opcodes in this case, because we want to translate any number of samples in the table to any number of output samples using different speed values. In short, we will need to read amplitude values that must be 'imagined' between two existing table value.
</p>
<p><img src="/csound/_v/1.0/http://en.flossmanuals.net/floss/pub/Csound/" height="0" width="0" />
</p>
<p><img title="101124table3" alt="101124table3" src="static/Csound-Picts-06_Samples-101124table3-en.png" height="643" width="605" />&nbsp;
</p>
<p>For higher or lower speed values than the original record speed, interpolation must be used in between certain sample values if the original shape of the wave is to be reproduced as accurately as possible. This job is performed with high quality by <a href="http://www.csounds.com/manual/html/table3.html">table3</a> which employs cubic interpolation.
</p>
<p>In a typical application of recording and playing buffer buffers, the ability to interact with the process will be paramount. We can benefit from having interactive access to the following:
</p>
<ul>
  <li>starting and stopping record</li>
</ul>
<ul>
  <li>adjusting the start and end points of recording</li>
  <li>use or prevent wraparound while recording</li>
  <li>starting and stopping playback</li>
  <li>adjusting the start and end points of playback</li>
  <li>adjusting wraparound in playback using one of the specified modes (1 - 4)&nbsp;</li>
  <li>applying volume control to the playback signal
  <br /></li>
</ul>
<p>These interactions could be carried out via widgets, MIDI, OSC or something else. As we want to provide examples which can be used with any Csound frontend here, we are restricted to triggering the record and play events by hitting the space bar of the computer keyboard. (See the CsoundQt version of this example for a more interactive version.)
</p>
<p>&nbsp;&nbsp; <em><strong>EXAMPLE 06B05_BufRecPlay_complex.csd</strong></em>&nbsp;&nbsp;
  <br />
</p>
<pre>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-i adc -o dac -d
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example written by joachim heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

  opcode BufCrt2, ii, io ;creates a stereo buffer
ilen, inum xin ;ilen = length of the buffer (table) in seconds
iftL      ftgen     inum, 0, -(ilen*sr), 2, 0
iftR      ftgen     inum, 0, -(ilen*sr), 2, 0
          xout      iftL, iftR
  endop

  opcode BufRec1, k, aikkkk ;records to a buffer
ain, ift, krec, kstart, kend, kwrap xin
		setksmps	1
kendsmps	=		kend*sr ;end point in samples
kendsmps	=		(kendsmps == 0 || kendsmps &gt; ftlen(ift) ? ftlen(ift) : kendsmps)
kfinished	=		0
knew		changed	krec ;1 if record just started
 if krec == 1 then
  if knew == 1 then
kndx		=		kstart * sr - 1 ;first index to write
  endif
  if kndx &gt;= kendsmps-1 &amp;&amp; kwrap == 1 then
kndx		=		-1
  endif
  if kndx &lt; kendsmps-1 then
kndx		=		kndx + 1
andx		=		kndx
		tabw		ain, andx, ift
  else
kfinished	=		1
  endif
 endif
 		xout		kfinished
  endop

  opcode BufRec2, k, aaiikkkk ;records to a stereo buffer
ainL, ainR, iftL, iftR, krec, kstart, kend, kwrap xin
kfin      BufRec1     ainL, iftL, krec, kstart, kend, kwrap
kfin      BufRec1     ainR, iftR, krec, kstart, kend, kwrap
          xout        kfin
  endop

  opcode BufPlay1, ak, ikkkkkk
ift, kplay, kspeed, kvol, kstart, kend, kwrap xin
;kstart = begin of playing the buffer in seconds
;kend = end of playing in seconds. 0 means the end of the table
;kwrap = 0: no wrapping. stops at kend (positive speed) or kstart
;  (negative speed).this makes just sense if the direction does not
;  change and you just want to play the table once
;kwrap = 1: wraps between kstart and kend
;kwrap = 2: wraps between 0 and kend
;kwrap = 3: wraps between kstart and end of table
;CALCULATE BASIC VALUES
kfin		init		0
iftlen		=		ftlen(ift)/sr ;ftlength in seconds
kend		=		(kend == 0 ? iftlen : kend) ;kend=0 means end of table
kstart01	=		kstart/iftlen ;start in 0-1 range
kend01		=		kend/iftlen ;end in 0-1 range
kfqbas		=		(1/iftlen) * kspeed ;basic phasor frequency
;DIFFERENT BEHAVIOUR DEPENDING ON WRAP:
if kplay == 1 &amp;&amp; kfin == 0 then
 ;1. STOP AT START- OR ENDPOINT IF NO WRAPPING REQUIRED (kwrap=0)
 if kwrap == 0 then
; -- phasor freq so that 0-1 values match distance start-end
kfqrel		=		kfqbas / (kend01-kstart01)
andxrel	phasor 	kfqrel ;index 0-1 for distance start-end
; -- final index for reading the table (0-1)
andx		=		andxrel * (kend01-kstart01) + (kstart01)
kfirst		init		1 ;don't check condition below at the first k-cycle (always true)
kndx		downsamp	andx
kprevndx	init		0
 ;end of table check:
  ;for positive speed, check if this index is lower than the previous one
  if kfirst == 0 &amp;&amp; kspeed &gt; 0 &amp;&amp; kndx &lt; kprevndx then
kfin		=		1
 ;for negative speed, check if this index is higher than the previous one
  else
kprevndx	=		(kprevndx == kstart01 ? kend01 : kprevndx)
   if kfirst == 0 &amp;&amp; kspeed &lt; 0 &amp;&amp; kndx &gt; kprevndx then
kfin		=		1
   endif
kfirst		=		0 ;end of first cycle in wrap = 0
  endif
 ;sound out if end of table has not yet reached
asig		table3		andx, ift, 1	
kprevndx	=		kndx ;next previous is this index
 ;2. WRAP BETWEEN START AND END (kwrap=1)
 elseif kwrap == 1 then
kfqrel		=		kfqbas / (kend01-kstart01) ;same as for kwarp=0
andxrel	phasor 	kfqrel
andx		=		andxrel * (kend01-kstart01) + (kstart01)
asig		table3		andx, ift, 1	;sound out
 ;3. START AT kstart BUT WRAP BETWEEN 0 AND END (kwrap=2)
 elseif kwrap == 2 then
kw2first	init		1
  if kw2first == 1 then ;at first k-cycle:
		reinit		wrap3phs ;reinitialize for getting the correct start phase
kw2first	=		0
  endif
kfqrel		=		kfqbas / kend01 ;phasor freq so that 0-1 values match distance start-end
wrap3phs:
andxrel	phasor 	kfqrel, i(kstart01) ;index 0-1 for distance start-end
		rireturn	;end of reinitialization
andx		=		andxrel * kend01 ;final index for reading the table
asig		table3		andx, ift, 1	;sound out
 ;4. WRAP BETWEEN kstart AND END OF TABLE(kwrap=3)
 elseif kwrap == 3 then
kfqrel		=		kfqbas / (1-kstart01) ;phasor freq so that 0-1 values match distance start-end
andxrel	phasor 	kfqrel ;index 0-1 for distance start-end
andx		=		andxrel * (1-kstart01) + kstart01 ;final index for reading the table
asig		table3		andx, ift, 1	
 endif
else ;if either not started or finished at wrap=0
asig		=		0 ;don't produce any sound
endif
  		xout		asig*kvol, kfin
  endop

  opcode BufPlay2, aak, iikkkkkk ;plays a stereo buffer
iftL, iftR, kplay, kspeed, kvol, kstart, kend, kwrap xin
aL,kfin   BufPlay1     iftL, kplay, kspeed, kvol, kstart, kend, kwrap
aR,kfin   BufPlay1     iftR, kplay, kspeed, kvol, kstart, kend, kwrap
          xout         aL, aR, kfin
  endop

  opcode In2, aa, kk ;stereo audio input
kchn1, kchn2 xin
ain1      inch      kchn1
ain2      inch      kchn2
          xout      ain1, ain2
  endop

  opcode Key, kk, k
;returns '1' just in the k-cycle a certain key has been pressed (kdown)
;  or released (kup)
kascii    xin ;ascii code of the key (e.g. 32 for space)
key,k0    sensekey
knew      changed   key
kdown     =         (key == kascii &amp;&amp; knew == 1 &amp;&amp; k0 == 1 ? 1 : 0)
kup       =         (key == kascii &amp;&amp; knew == 1 &amp;&amp; k0 == 0 ? 1 : 0)
          xout      kdown, kup
  endop

instr 1
giftL,giftR BufCrt2   3 ;creates a stereo buffer for 3 seconds
gainL,gainR In2     1,2 ;read input channels 1 and 2 and write as global audio
          prints    "PLEASE PRESS THE SPACE BAR ONCE AND GIVE AUDIO INPUT
                     ON CHANNELS 1 AND 2.\n"
          prints    "AUDIO WILL BE RECORDED AND THEN AUTOMATICALLY PLAYED
                     BACK IN SEVERAL MANNERS.\n"
krec,k0   Key       32
 if krec == 1 then
          event     "i", 2, 0, 10
 endif
endin

instr 2
; -- records the whole buffer and returns 1 at the end
kfin      BufRec2   gainL, gainR, giftL, giftR, 1, 0, 0, 0
  if kfin == 0 then
          printks   "Recording!\n", 1
  endif
 if kfin == 1 then
ispeed    random    -2, 2
istart    random    0, 1
iend      random    2, 3
iwrap     random    0, 1.999
iwrap     =         int(iwrap)
printks "Playing back with speed = %.3f, start = %.3f, end = %.3f,
                    wrap = %d\n", p3, ispeed, istart, iend, iwrap
aL,aR,kf  BufPlay2  giftL, giftR, 1, ispeed, 1, istart, iend, iwrap
  if kf == 0 then
          printks   "Playing!\n", 1
  endif
 endif
krel      release
 if kfin == 1 &amp;&amp; kf == 1 || krel == 1 then
          printks   "PRESS SPACE BAR AGAIN!\n", p3
          turnoff
 endif
          outs      aL, aR
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1000
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</pre>
<p>
</p>
<h2>Further Opcodes for Investigation
</h2>
<p>Csound contains a wide range of opcodes that offer a variety of 'ready-made' methods of playing back audio held in a function table. The oldest group of these opcodes are <a href="http://www.csounds.com/manual/html/loscil.html">loscil</a> and <a href="http://www.csounds.com/manual/html/loscil3.html">loscil3</a>. Despite their age they offer some unique features such as the ability implement both sustain and release stage looping (in a variety of looping modes), their ability to read from stereo as well as mono function tables and their ability to read looping and base frequency data from the sound file stored in the function table. loscil and loscil3 were originally intended as the kernel mechanism for building a sampler.
</p>
<p>For reading multichannel files&nbsp; of more than two channels, the more recent <a href="http://www.csounds.com/manual/html/loscilx.html">loscilx</a> exists as an option.
</p>
<p>loscil and loscil3 will only allow looping points to be defined at i-time. <a href="http://www.csounds.com/manual/html/lposcil.html">lposcil</a>, <a href="http://www.csounds.com/manual/html/lposcil3.html">lposcil3</a>, <a href="http://www.csounds.com/manual/html/lposcila.html">lposcila</a>, <a href="http://www.csounds.com/manual/html/lposcilsa.html">lposcilsa</a> and <a href="http://www.csounds.com/manual/html/lposcilsa2.html">lposcilsa2</a> will allow looping points to be changed a k-rate, while the note is playing.
</p>
<p>It is worth not forgetting Csound's more exotic methods of playback of sample stored in function tables. <a href="http://www.csounds.com/manual/html/mincer.html">mincer</a> and <a href="http://www.csounds.com/manual/html/temposcal.html">temposcal</a> use streaming vocoder techniques to faciliate independent pitch and time-stretch control during playback (this area is covered more fully in the chapter <a href="http://en.flossmanuals.net/csound/i-fourier-analysis-spectral-processing/">FOURIER ANALYSIS / SPECTRAL PROCESSING</a>. <a href="http://www.csounds.com/manual/html/sndwarp.html">sndwarp</a> and <a href="http://www.csounds.com/manual/html/sndwarpst.html">sndwarpst</a> similiarly faciliate independent pitch and playback speed control but through the technique of granular synthesis this area is covered in detail in the chapter <a href="http://en.flossmanuals.net/csound/g-granular-synthesis/">GRANULAR SYNTHESIS</a>.
  <br />
</p>
<p>
</p>
   <hr/>
    <a href="/csound/_edit/">EDIT</a>

</div>

<script type="text/javascript">
jQuery(function ($) {
    $('#bookcontent').annotator()
   		.annotator('setupPlugins', {}, {
                Tags: false,
                Filter: {
                  addAnnotationFilter: false
                },
                Permissions: false,
                AnnotateItPermissions: {}
              });
});
</script>



</div>
<!-- End of content -->

</div>  
<!-- DEV TOOLS -->
<div id="bookidebug">
</div>

<!-- sputnik error page -->
<div id="dialog-sputnik-qrac" style="display: none"></div>
</body>
</html>

