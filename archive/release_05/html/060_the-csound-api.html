
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> 
<html>
 <head>
   <link type="text/css" href="http://www.flossmanuals.net/_templates/prettify/src/prettify.css" rel="Stylesheet" />
   <script type="text/javascript" src="http://www.flossmanuals.net/_templates/prettify/src/prettify.js"></script>

   <link type="text/css" href="/site_static/js/jquery/themes/base/jquery.ui.all.css" rel="Stylesheet" >
   <link type="text/css" href="/site_static/js/jquery/themes/smoothness/jquery.ui.all.css" rel="Stylesheet" >
   <script type="text/javascript" src="/static/js/jquery-1.7.js"></script>
<!--
   <script type="text/javascript" src="/site_static/js/jquery/jquery-1.4.4.js"></script>
-->   
<script type="text/javascript" src="/site_static/js/jquery/ui/jquery-ui-1.8.10.custom.js"></script>
   <script type="text/javascript" src="/site_static/js/jquery.json-1.3.js"></script>
   <script type="text/javascript" src="/site_static/js/booki.js"></script>

   <link href="/site_static/css/jquery.bubblepopup.v2.3.1.css" rel="stylesheet" type="text/css" />
   <script src="/site_static/js/jquery.bubblepopup.v2.3.1.min.js" type="text/javascript"></script>

   <link type="text/css" href="/static/css/booki_fm.css" rel="Stylesheet"/ >
<style>
.template {
	display: none !important;
}


#header {
    background-color: transparent !important;
}
.paginator { padding:.5em .75em; float:left; font:normal .8em arial; }
 
.paginator .prev-na,
.paginator .next-na {
	padding:.3em;
	font-weight: bold;
/*	font:bold .875em arial; */
}
 
.paginator .prev-na,
.paginator .next-na {
/*	border:1px solid #ccc; 
	background-color:#f9f9f9; */
	color:#aaa;
	font-weight:normal;
}
 
.paginator .prev a, .paginator .prev a:visited,
.paginator .next a, .paginator .next a:visited {
/*	border:1px solid #c2ee62; 
	background-color:#edfdd0; */
	color:#234f32;
	padding:.3em;
/*	font:bold .875em arial; */
        font-weight: bold;
}
 
.paginator .prev, .paginator .prev-na { margin-right:.5em; }
.paginator .next, .paginator .next-na { margin-left:.5em; }
 
.paginator .page a, .paginator .page a:visited, .paginator .curr {
	padding:.25em;
	font-weight: normal;
/*	font:normal .875em verdana; */
/*	border:1px solid #C2EE62; 
	background-color:#EDFDD0; */
	margin:0em .25em;	
	color:#006000;
}
 
.paginator .curr { 
/*	background-color:#234f32; 
	color:#fff; */
	border:1px solid #234f32; 
	font-weight:bold;
	font-size:1em;
}
 
.paginator .page a:hover,
.paginator .curr a:hover,
.paginator .prev a:hover,
.paginator .next a:hover {
/*	color:#fff;
	background-color:#234f32;
	border:1px solid #234f32; */
}
</style>
 <script type="text/javascript">
      $(function() {
   $.booki.sputnikDispatcherURL = "/_sputnik/";
    });
   </script>

   <script type="text/javascript">
     $(function() {
	 // open debug window
	 $.booki.debug.init();
	 
	 
	 $("A.debug").click(function() {
	     $("#bookidebug").dialog("open");
	     return false;
	 });
     });
   </script>

   
<title>/chapter: The-Csound-Api / CSound</title>
<link type="text/css" href="/site_static/css/editor.css" rel="Stylesheet" />

<script src="http://assets.annotateit.org/annotator/v1.2.5/annotator-full.min.js"></script>
<link rel="stylesheet" href="http://assets.annotateit.org/annotator/v1.2.5/annotator.min.css">



<link rel="alternate" type="application/rss+xml" title="RSS feed for CSound" href="/feeds/rss/book/csound/" /> 
<link rel="alternate" type="application/atom+xml" title="Atom feed for CSound" href="/feeds/atom/book/csound/" /> 

<link rel="alternate" type="application/rss+xml" title="RSS feed for chapter The-Csound-Api" href="/feeds/rss/chapter/csound/csound/" /> 
<link rel="alternate" type="application/atom+xml" title="Atom feed for chapter The-Csound-Api" href="/feeds/atom/chapter/csound/csound/" /> 


 </head>
<body onload="prettyPrint()" >
<!-- testis -->

<script type="text/javascript">
$(function() {
    $("#snippetdialog").dialog({autoOpen: false});
});
</script>


<div id="snippetdialog" title="Basic dialog">
        <p></p>
</div>



<div id="page-container"> 
<style>
body
{
margin:0;
padding:0
}
#header
{
position:absolute;
top:23px;
width:100%;
background-image: url('http://www.flossmanuals.net/_templates/fm_resources/header_bg.gif');
background-position: 700px 0px; /* this places the orange background at
an offset, making sure it doesn't underlap the left side of the gif */
background-repeat: no-repeat;
}

#fmheader {
    background-image: url("http://en.flossmanuals.net/_templates/fm_resources/header_bg.gif");
    background-position: 600px 0;
    background-repeat: no-repeat;
    position: absolute;
    top: 23px;
    width: 100%;
}
#header_image
{
margin-left: 270px;
border: 0px
}

#navigation
{
position:absolute;
top: 80px;
left: 357px;
width:50%;
}


#languages
{
position:absolute;
top: 40px;
left: 740px;
width:50%;
}
</style>



<!-- Header graphic is common to all pages  -->
<div id="header"><img id="header_image" alt="FlossManuals menu" src="http://www.flossmanuals.net/_templates/fm_resources/header_menu.gif" height="95" width="465" border="0"></div>


<!-- Navigation buttons are language and context specific  -->
<div id="navigation">
<a title="Read" href="http://en.flossmanuals.net/index.php"><img src="http://www.flossmanuals.net/_templates/fm_resources/read_en.png" width="65" height="30" border="0" alt="Read"></a>
<a title="Write" href="http://booki.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/write_active_en.png" width="65" height="30" border="0" alt="Write"></a>
<a title="Remix" href="http://en.flossmanuals.net/index.php?plugin=remix"><img src="http://www.flossmanuals.net/_templates/fm_resources/remix_en.png" width="65" height="30" border="0" alt="Remix"></a>
<a title="About" href="http://www.flossmanuals.org"><img src="http://www.flossmanuals.net/_templates/fm_resources/about_en.png" width="65" height="30" border="0" alt="About"></a>
</div>

<!-- Language buttons are common to all pages  -->
<div id="languages">
<a title="English" href="http://en.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/english_button.png" width="65" height="30" border="0" alt="English"></a>

<!-- <a title="Español" href="http://es.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/spanish_button.png" width="65" height="30" border="0" alt="Español"></a> -->
<a title="فارسی" href="http://fa.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/farsi_button.png" width="65" height="30" border="0" alt="فارسی"></a>
<a title="Suomi" href="http://fi.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/finnish_button.png" width="65" height="30" border="0" alt="Suomi"></a>
<br>
<a title="Français" href="http://fr.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/french_button.png" width="65" height="30" border="0" alt="Français"></a>
<a title="Nederlands" href="http://nl.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/dutch_button.png" width="65" height="30" border="0" alt="Nederlands"></a>
<!-- <a title="Pусский" href="http://ru.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/russian_button.png" width="65" height="30" border="0" alt="Pусский"></a> -->
<a title="Translate" href="http://translate.flossmanuals.net/"><img src="http://www.flossmanuals.net/_templates/fm_resources/translate_button.png" width="65" height="30" border="0" alt="Translate"></a>
</div>

<!-- End top bar -->

<!-- nav box + drop shadow -->
<div class="navbox shadow" style="top:160px;">
    		<ul>

 		<li><a href="/accounts/signin/?redirect=/csound/_draft/_v/1.0/the-csound-api/">Sign In</li><li>Register</a></li>

                <li><a href="/list-books">All Manuals</a></li>
                <li><a href="/list-groups">All Groups</a></li>
                <li><a href="/list-people/">All People</a></li>
           	</ul>
</div>
<!-- End of nav box -->



<div class="content-container shadow">
<!-- Content box and the drop shadow-->




<br clear="all"/>
   <h1>CSound</h1>


<div id="bookmenu"   style="background: url(/site_static/images/draft_bg.png) repeat !important;">
<ul>

 
   <li><b>INTRODUCTION</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/introduction/">PREFACE</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/how-to-use-this-manual/">HOW TO USE THIS MANUAL</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/on-this-release/">ON THIS RELEASE</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/credits/">CREDITS</a></li>
 

 
   <li><b>01 BASICS</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-digital-audio/">A. DIGITAL AUDIO</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-pitch-and-frequency/">B. PITCH AND FREQUENCY</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-intensities/">C. INTENSITIES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/random/">D. RANDOM</a></li>
 

 
   <li><b>02 QUICK START</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-make-csound-run/">A. MAKE CSOUND RUN</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-csound-syntax/">B. CSOUND SYNTAX</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-configuring-midi/">C. CONFIGURING MIDI</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-live-audio/">D. LIVE AUDIO</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/e-rendering-to-file/">E. RENDERING TO FILE</a></li>
 

 
   <li><b>03 CSOUND LANGUAGE</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-initialization-and-performance-pass/">A. INITIALIZATION AND PERFORMANCE PASS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-local-and-global-variables/">B. LOCAL AND GLOBAL VARIABLES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-control-structures/">C. CONTROL STRUCTURES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-function-tables/">D. FUNCTION TABLES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/arrays/">E. ARRAYS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/e-triggering-instrument-events/">F. LIVE EVENTS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/f-user-defined-opcodes/">G. USER DEFINED OPCODES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/macros/">H. MACROS</a></li>
 

 
   <li><b>04 SOUND SYNTHESIS</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-additive-synthesis/">A. ADDITIVE SYNTHESIS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-subtractive-synthesis/">B. SUBTRACTIVE SYNTHESIS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-amplitude-and-ringmodulation/">C. AMPLITUDE AND RING MODULATION</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-frequency-modulation/">D. FREQUENCY MODULATION</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/e-waveshaping/">E. WAVESHAPING</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/f-granular-synthesis/">F. GRANULAR SYNTHESIS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/g-physical-modelling/">G. PHYSICAL MODELLING</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/scanned-synthesis/">H. SCANNED SYNTHESIS</a></li>
 

 
   <li><b>05 SOUND MODIFICATION</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-envelopes/">A. ENVELOPES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-panning-and-spatialization/">B. PANNING AND SPATIALIZATION</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-filters/">C. FILTERS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-delay-and-feedback/">D. DELAY AND FEEDBACK</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/e-reverberation/">E. REVERBERATION</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/f-am-rm-waveshaping/">F. AM / RM / WAVESHAPING</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/g-granular-synthesis/">G. GRANULAR SYNTHESIS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/h-convolution/">H. CONVOLUTION</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/i-fourier-analysis-spectral-processing/">I. FOURIER ANALYSIS / SPECTRAL PROCESSING</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/k-ats-resynthesis/">K. ATS RESYNTHESIS</a></li>
 

 
   <li><b>06 SAMPLES</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-record-and-play-soundfiles/">A. RECORD AND PLAY SOUNDFILES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-record-and-play-buffers/">B. RECORD AND PLAY BUFFERS</a></li>
 

 
   <li><b>07 MIDI</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/a-receiving-events-by-midiin/">A. RECEIVING EVENTS BY MIDIIN</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/b-triggering-instrument-instances/">B. TRIGGERING INSTRUMENT INSTANCES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-working-with-controllers/">C. WORKING WITH CONTROLLERS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-reading-midi-files/">D. READING MIDI FILES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/e-midi-output/">E. MIDI OUTPUT</a></li>
 

 
   <li><b>08 OTHER COMMUNICATION</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/osc-and-wii/">A. OPEN SOUND CONTROL</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/csound-in-arduino/">B. CSOUND AND ARDUINO</a></li>
 

 
   <li><b>09 CSOUND IN OTHER APPLICATIONS</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/csound-in-pd/">A. CSOUND IN PD</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/csound-in-maxmsp/">B. CSOUND IN MAXMSP</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/csound-in-ableton-live/">C. CSOUND IN ABLETON LIVE</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-csound-as-a-vst-plugin/">D. CSOUND AS A VST PLUGIN</a></li>
 

 
   <li><b>10 CSOUND FRONTENDS</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/qutecsound/">CSOUNDQT</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/cecilia/">CABBAGE</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/blue/">BLUE</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/winxound/">WINXOUND</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/csound-via-terminal/">CSOUND VIA TERMINAL</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/web-based-csound/">WEB BASED CSOUND</a></li>
 

 
   <li><b>11 CSOUND UTILITIES</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/csound-utilities/">CSOUND UTILITIES</a></li>
 

 
   <li><b>12 CSOUND AND OTHER PROGRAMMING LANGUAGES</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/the-csound-api/">A. THE CSOUND API</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/using-python-inside-csound/">B. PYTHON INSIDE CSOUND</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/c-python-in-csoundqt/">C. PYTHON IN CSOUNDQT</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/d-lua-in-csound/">D. LUA IN CSOUND</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/e-csound-in-ios/">E. CSOUND IN iOS</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/f-csound-on-android/">F. CSOUND ON ANDROID</a></li>
 

 
   <li><b>13 EXTENDING CSOUND</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/extending-csound/">EXTENDING CSOUND</a></li>
 

 
   <li><b>OPCODE GUIDE</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/overview/">OVERVIEW</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/signal-processing-i/">SIGNAL PROCESSING I</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/signal-processing-ii/">SIGNAL PROCESSING II</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/data/">DATA</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/realtime-interaction/">REALTIME INTERACTION</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/instrument-control/">INSTRUMENT CONTROL</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/math-pythonsystem-plugins/">MATHS, PYTHON/SYSTEM, PLUGINS</a></li>
 

 
   <li><b>APPENDIX</b></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/writing-csound-scores-by-hand/">METHODS OF WRITING CSOUND SCORES</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/glossary/">GLOSSARY</a></li>
 

 
   <li><a href="/csound/_draft/_v/1.0/links/">LINKS</a></li>
 

</ul>
</div>
<div id="bookcontent"   >
<title>Csound: THECSOUNDAPI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<h1>THE CSOUND API
</h1>An application programming interface (API) is an interface provided by a computer system,&nbsp;library or application that allows users to access functions and routines for a particular task. It&nbsp;gives developers a way to harness the functionality of existing software within a host&nbsp;application. The Csound API can be used to control an instance of Csound through a series of different functions thus&nbsp;making it possible to harness all the power of Csound in one’s own applications. In other words, almost anything that can be done within Csound can be done with the API. The API is&nbsp;written in C, but there are interfaces to other languages as well, such as Python, C++ and&nbsp;Java. &nbsp;&nbsp;
<p>To use the Csound C API, you have to include csound.h in your source file and to link your code with libcsound. Here is an example of the csound command line application written using the Csound C API:
</p>
<pre>#include &lt;csound/csound.h&gt;

int main(int argc, char **argv)
{
  CSOUND *csound = csoundCreate(NULL);
  int result = csoundCompile(csound, argc, argv);
  if (result == 0) {
    result = csoundPerform(csound);
  }
  csoundDestroy(csound);
  return (result &gt;= 0 ? 0 : result);
}
</pre>
<p> First we create an instance of Csound. To do this we call <font class="Apple-style-span" face="'courier new', courier, monospace">csoundCreate</font>() which returns an opaque pointer that will be passed to most Csound API functions. Then we compile the orc/sco files or the csd file given as input arguments through the argv parameter of the main function. If the compilation is successful (result == 0), we call the <font class="Apple-style-span" face="'courier new', courier, monospace">csoundPerform</font>() function. <font class="Apple-style-span" face="'courier new', courier, monospace">csoundPerform</font>() will cause Csound to perform until the end of the score is reached. When this happens csoundPerform() returns a non-zero value and we destroy our instance before ending the program.
</p>
<p>On a linux system, with libcsound named libcsound64 (double version of the csound library), supposing that all include and library paths are set correctly, we would build the above example with the following command (notice the use of the -DUSE_DOUBLE flag to signify that we compile against the 64 bit version of the csound library):
</p>
<pre>gcc -DUSE_DOUBLE -o csoundCommand csoundCommand.c -lcsound64
</pre>
<p>&nbsp;The command for building with a 32 bit version of the library would be:
</p>
<p>
</p>
<pre>gcc -o csoundCommand csoundCommand.c -lcsound</pre>
<p>Within the C or C++ examples of this chapter, we will use the MYFLT type for the audio samples. Doing so, the same source files can be used for both development (32 bit or 64 bit), the compiler knowing how to interpret MYFLT as double if the macro USE_DOUBLE is defined, or as float if the macro is not defined.
  <br />
</p>
<p>The C API has been wrapped in a C++ class for convenience. This gives the Csound basic C++ API. With this API, the above example would become:
</p>
<pre>#include &lt;csound/csound.hpp&gt;

int main(int argc, char **argv)
{
  Csound *cs = new Csound();
  int result = cs-&gt;Compile(argc, argv);
  if (result == 0) {
    result = cs-&gt;Perform();
  }
  return (result &gt;= 0 ? 0 : result);
}
</pre>
<p>Here, we get a pointer to a Csound object instead of the csound opaque pointer. We call methods of this object instead of C functions, and we don't need to call csoundDestroy in the end of the program, because the C++ object destruction mechanism takes care of this. On our linux system, the example would be built with the following command:
</p>
<pre>g++ -DUSE_DOUBLE -o csoundCommandCpp csoundCommand.cpp -lcsound64
</pre>
<p>The Csound API has also been wrapped to other languages. The Csound Python API wraps the Csound API to the Python language. To use this API, you have to import the csnd module. The csnd module is normally installed in the site-packages or dist-packages directory of your python distribution as a csnd.py file. Our csound command example becomes:
</p>
<pre>import sys
import csnd

def csoundCommand(args):
    csound = csnd.Csound()
    arguments = csnd.CsoundArgVList()
    for s in args:
        arguments.Append(s)
    result = csound.Compile(arguments.argc(), arguments.argv())
    if result == 0:
        result = csound.Perform()
    return result

def main():
    csoundCommand(sys.argv)

if __name__ =='__main__':
    main()
</pre>
<p>We use a Csound object (remember Python has OOp features). Note the use of the CsoundArgVList helper class to wrap the program input arguments into a C++ manageable object. In fact, the Csound class has syntactic sugar (thanks to method&nbsp; overloading) for the Compile method. If you have less than six string arguments to pass to this method, you can pass them directly. But here, as we don't know the number of arguments to our csound command, we use the more general mechanism of the CsoundArgVList helper class.
</p>
<p>The Csound Java API wraps the Csound API to the Java language. To use this API, you have to import the csnd package. The csnd package is located in the csnd.jar archive which has to be known from your Java path. Our csound command example becomes:
</p>
<pre>import csnd.*;

public class CsoundCommand
{
  private Csound csound = null;
  private CsoundArgVList arguments = null;

  public CsoundCommand(String[] args) {
    csound = new Csound();
    arguments = new CsoundArgVList();
    arguments.Append("dummy");
    for (int i = 0; i &lt; args.length; i++) {
      arguments.Append(args[i]);
    }
    int result = csound.Compile(arguments.argc(), arguments.argv());
    if (result == 0) {
      result = csound.Perform();
    }
    System.out.println(result);
  }


  public static void main(String[] args) {
    CsoundCommand csCmd = new CsoundCommand(args);
  }
}
</pre>
<p>Note the "dummy" string as first argument in the arguments list. C, C++ and Python expect that the first argument in a program argv input array is implicitly the name of the calling program. This is not the case in Java: the first location in the program argv input array contains the first command line argument if any.&nbsp; So we have to had this "dummy" string value in the first location of the arguments array so that the C API function called by our csound.Compile method is happy.
</p>
<p> This illustrates a fundamental point about the Csound API. Whichever API wrapper is used (C++, Python, Java, etc), it is the C API which is working under the hood. So a thorough knowledge of the Csound C API is highly recommended if you plan to use the Csound API in any of its different flavours. The main source of information about the Csound C API is the csound.h header file which is fully commented.
</p>
<p>On our linux system, with csnd.jar located in /usr/local/lib/csound/java, our Java Program would be compiled and run with the following commands:
</p>
<pre>javac -cp /usr/local/lib/csound/java/csnd.jar CsoundCommand.java
java -cp /usr/local/lib/csound/java/csnd.jar:. CsoundCommand
</pre>
<p>There also exists an extended Csound C++ API, which adds to the Csound C++ API a&nbsp;CsoundFile class,&nbsp;the CsoundAC C++ API, which provides a class hierarchy for doing algorithmic composition using Michael Gogins' concept of music graphs, and API wrappers for the LISP, LUA and HASKELL languages.
</p>
<p>For now, in this chapter we will focus on the basic C/C++ API, and the Python and Java API.
</p>
<h2 style="font-size: 18px; font-family: Arial,verdana,sans-serif; font-weight: bold; margin-bottom: 10px; margin-top: 15px; padding-top: 15px;">Threading
</h2>
<p>Before we begin to look at how to control Csound in real time we need to look at threads.&nbsp;Threads are used so that a program can split&nbsp;itself into two or more simultaneously running tasks. Multiple threads can be executed in&nbsp;parallel on many computer systems. The advantage of running threads is that you do not&nbsp;have to wait for one part of your software to finish executing before you start another.
</p>
<p>In order to control aspects of your instruments in real time your will need to employ the use of threads. If you run the first example found on this page you will see that the host will run for as long as&nbsp;<font class="Apple-style-span" face="'courier new', courier, monospace">csoundPerform</font>() returns 0. As soon as it returns non-zero it will exit the loop and cause the application to quit. Once called,&nbsp;<font class="Apple-style-span" face="'courier new', courier, monospace">csoundPerform</font>() will cause the program to hang until it is finished. In order to interact with Csound while it is performing you will need to call csoundPerform() in a&nbsp;separate unique&nbsp;thread.&nbsp;
</p>
<p>When implementing threads using the Csound API, we must define a special performance&nbsp;function thread. We then pass the name of this performance function to <font class="Apple-style-span" face="'courier new', courier, monospace">csoundCreateThread</font>(), thus registering our performance-thread function with Csound. When defining a Csound performance-thread routine you must declare&nbsp;it to have a return type uintptr_t, hence it will need to return a value when called. The thread&nbsp;function will take only one parameter, a pointer to void. This pointer to void is quite important as it allows us to pass important data from the main thread to the performance thread. As several variables are needed in our thread function the best approach is to create a user defined data structure that will hold all the information your performance thread will need. For example:
</p>
<pre>typedef struct {&nbsp;
  int result;        /* result of csoundCompile() */&nbsp;
 &nbsp;CSOUND *csound;    /* instance of csound */
  bool PERF_STATUS; &nbsp;/* performance status */&nbsp;
} userData; </pre>
<p>Below is a basic performance-thread routine. <font class="Apple-style-span" face="'courier new', courier, monospace">*data</font> is cast as a <font class="Apple-style-span" face="'courier new', courier, monospace">userData</font> data type so that we can access its members.&nbsp;
</p>
<pre>uintptr_t csThread(void *data)
{
  userData *udata = (userData *)data;
  if (!udata-&gt;result) {
    while ((csoundPerformKsmps(udata-&gt;csound) == 0) &amp;&amp;
<span class="Apple-tab-span" style="white-space: pre;">           </span>(udata-&gt;PERF_STATUS == 1));
    csoundDestroy(udata-&gt;csound);
  }
  udata-&gt;PERF_STATUS = 0;
  return 1;
} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</pre>
<p>In order to start this thread we must call the csoundCreateThread() API function which is declared in csound.h as:&nbsp;&nbsp;
</p>
<pre>void *csoundCreateThread(uintptr_t (*threadRoutine (void *),
                         void *userdata); &nbsp;</pre>
<p>If you are building a command line program you will need to use some kind of&nbsp;mechanism to prevent int main() from returning until after the performance has taken&nbsp;place. A simple while loop will suffice.&nbsp;
</p>
<p>The first example presented above can now be rewritten to include a unique performance thread:
</p>
<p>
</p>
<pre style="font-size: 12px; line-height: 1.5em; background-color: rgb(255, 229, 204); border: 0px solid rgb(0, 0, 0); margin-left: 0.5em; margin-bottom: 20px; margin-right: 1em; padding: 0.2em 1em; color: black; white-space: pre-wrap; word-wrap: break-word;"><span class="Apple-style-span" style="font-family: trebuchet,verdana,sans-serif; line-height: 17px; white-space: normal;">
</span>#include &lt;stdio.h&gt;&nbsp;
#include &lt;csound/csound.h&gt;&nbsp;

uintptr_t csThread(void *clientData);&nbsp;

typedef struct {&nbsp;
  int result;&nbsp;
  CSOUND *csound;&nbsp;
  int PERF_STATUS;&nbsp;
} userData;&nbsp;

int main(int argc, char *argv[])&nbsp;
{
  int finish;
  void *ThreadID;&nbsp;
  userData *ud;&nbsp;
  ud = (userData *)malloc(sizeof(userData));&nbsp;&nbsp;
  MYFLT *pvalue;&nbsp;
  ud-&gt;csound = csoundCreate(NULL); &nbsp;
  ud-&gt;result = csoundCompile(ud-&gt;csound, argc, argv);&nbsp;

  if (!ud-&gt;result) {&nbsp;&nbsp;
    ud-&gt;PERF_STATUS = 1;&nbsp;
    ThreadID = csoundCreateThread(csThread, (void *)ud);&nbsp;
  }&nbsp;
  else {&nbsp;
    return 1;&nbsp;
  } &nbsp;

  /* keep performing until user types a number and presses enter */
  scanf("%d", &amp;finish);
  ud-&gt;PERF_STATUS = 0;&nbsp;
  csoundDestroy(ud-&gt;csound);&nbsp;
  free(ud); &nbsp;
  return 0;&nbsp;
}&nbsp;

/* performance thread function */
uintptr_t csThread(void *data)&nbsp;
{&nbsp;
&nbsp; userData *udata = (userData *)data;&nbsp;
&nbsp; if (!udata-&gt;result) {
&nbsp; &nbsp; while ((csoundPerformKsmps(udata-&gt;csound) == 0) &amp;&amp;
           (udata-&gt;PERF_STATUS == 1));
    csoundDestroy(udata-&gt;csound);&nbsp;
&nbsp; } &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; udata-&gt;PERF_STATUS = 0; &nbsp; &nbsp;
&nbsp; return 1;&nbsp;
} &nbsp;</pre>
<p>
</p>
<p>The application above might not appear all that interesting. In fact it's almost the exact same as the first example presented except that users can now stop Csound by hitting 'enter'. &nbsp;The real worth of threads can only be appreciated when you start to control your instrument in real time.
</p>
<p>&nbsp;
</p>
<p><span class="Apple-style-span" style="font-family: Arial,verdana,sans-serif; font-size: 18px; font-weight: bold;">Channel I/O</span>
</p>
<p>The big advantage to using the API is that it allows a host to control your Csound instruments in real time.&nbsp;There are several mechanisms provided by the API&nbsp;that allow us to do this. The simplest mechanism makes use of a 'software bus'.
</p>
<p>The term bus is usually used to describe a means of communication between hardware&nbsp;components. Buses are used in mixing consoles to route signals out of the mixing desk into&nbsp;external devices. Signals get sent through the sends and are taken back into the console&nbsp;through the returns. The same thing happens in a software bus, only instead of sending&nbsp;analog signals to different hardware devices we send data to and from different software.&nbsp;
</p>
<p>Using one of the software bus opcodes in Csound we can provide an interface for&nbsp;communication with a host application. An example of one such opcode is <a href="http://www.csounds.com/manual/html/chnget.html">chnget</a>. The <em>chnget</em><font class="Apple-style-span" face="georgia, 'times new roman', times, serif"> </font>opcode reads data that is being sent from a host Csound API application on a&nbsp;particular named channel, and assigns it to an output variable. In the following example instrument 1 retrieves any data the host may be sending on a channel named "pitch":
</p>
<pre>instr 1&nbsp;
kfreq chnget "pitch"&nbsp;
asig  oscil  10000, kfreq, 1&nbsp;
      out    asig
endin&nbsp;</pre>
<p>One way in which data can be&nbsp;sent from a host application to an instance of Csound is through the use of the&nbsp;csoundGetChannelPtr() API function which is defined in csound.h as: &nbsp;&nbsp;
</p>
<p><font class="Apple-style-span" face="'courier new', courier, monospace">int csoundGetChannelPtr(CSOUND *, MYFLT **p, const char *name, &nbsp;int type); </font>
</p>
<p>CsoundGetChannelPtr() stores a pointer to the specified channel of the bus in p. The&nbsp;channel pointer p is of type MYFLT<strong> *</strong>. The argument name is the name of the channel and the argument type is a bitwise OR of&nbsp;exactly one of the following values:&nbsp;&nbsp;
</p>
<p><font class="Apple-style-span" face="'courier new', courier, monospace">CSOUND_CONTROL_CHANNEL</font> - control data (one MYFLT value)&nbsp;
  <br /><font class="Apple-style-span" face="'courier new', courier, monospace">CSOUND_AUDIO_CHANNEL</font> - audio data (ksmps MYFLT values)&nbsp;
  <br /><font class="Apple-style-span" face="'courier new', courier, monospace">CSOUND_STRING_CHANNEL</font> - string data (MYFLT values with enough space to store&nbsp;csoundGetStrVarMaxLen(CSOUND*) characters, including the&nbsp;NULL character at the end of the string) &nbsp;&nbsp;
</p>
<p>and at least one of these:&nbsp;&nbsp;
</p>
<p><font class="Apple-style-span" face="'courier new', courier, monospace">CSOUND_INPUT_CHANNEL</font> - when you need Csound to accept incoming values from a host
  <br /><font class="Apple-style-span" face="'courier new', courier, monospace">CSOUND_OUTPUT_CHANNEL</font> - when you need Csound to send outgoing values to a host&nbsp;
</p>
<p>If the call to csoundGetChannelPtr() is successful the function will return&nbsp;zero. If not, it will return a negative error code.&nbsp;We can now modify our previous code in&nbsp;order to send data from our application on a named software bus to an instance of Csound&nbsp;using csoundGetChannelPtr().
</p>
<p>
</p>
<pre style="font-size: 12px; line-height: 1.5em; background-color: rgb(255, 229, 204); border: 0px solid rgb(0, 0, 0); margin-left: 0.5em; margin-bottom: 20px; margin-right: 1em; padding: 0.2em 1em; color: black; white-space: pre-wrap; word-wrap: break-word;">#include &lt;stdio.h&gt;&nbsp;
#include &lt;csound/csound.h&gt;

/* performance thread function prototype */
uintptr_t csThread(void *clientData);

/* userData structure declaration */
typedef struct {
  int result;
  CSOUND *csound;
  int PERF_STATUS;
} userData;

/*-----------------------------------------------------------
 * main function
 *-----------------------------------------------------------*/
int main(int argc, char *argv[])
{
  int userInput = 200;
  void *ThreadID;
  userData *ud;
  ud = (userData *)malloc(sizeof(userData));
  MYFLT *pvalue;
  ud-&gt;csound = csoundCreate(NULL);
  ud-&gt;result = csoundCompile(ud-&gt;csound, argc, argv);
  if (csoundGetChannelPtr(ud-&gt;csound, &amp;pvalue, "pitch",
          CSOUND_INPUT_CHANNEL | CSOUND_CONTROL_CHANNEL) != 0) {
    printf("csoundGetChannelPtr could not get the \"pitch\" channel");
    return 1;
  }
  if (!ud-&gt;result) {
    ud-&gt;PERF_STATUS = 1;
    ThreadID = csoundCreateThread(csThread, (void*)ud);
  }
  else {
    printf("csoundCompiled returned an error");
    return 1;
  }
  printf("\nEnter a pitch in Hz(0 to Exit) and type return\n");
  while (userInput != 0) {
    *pvalue = (MYFLT)userInput;
    scanf("%d", &amp;userInput);
  }
  ud-&gt;PERF_STATUS = 0;
  csoundDestroy(ud-&gt;csound);
  free(ud);
  return 0;
}

/*-----------------------------------------------------------
 * definition of our performance thread function
 *-----------------------------------------------------------*/
uintptr_t csThread(void *data)
{
  userData *udata = (userData *)data;
  if (!udata-&gt;result) {
    while ((csoundPerformKsmps(udata-&gt;csound) == 0) &amp;&amp;
           (udata-&gt;PERF_STATUS == 1));
    csoundDestroy(udata-&gt;csound);
  }
  udata-&gt;PERF_STATUS = 0;
  return 1;
}&nbsp;
</pre>
<p>&nbsp;
</p>
<h2 style="font-size: 18px; font-family: Arial,verdana,sans-serif; font-weight: bold; margin-bottom: 10px; margin-top: 15px; padding-top: 15px;">Score Events&nbsp;
</h2>
<p>Adding score events to the csound instance is easy to do. It requires that csound has its threading done, see the paragraph above on threading. To enter a score event into csound, one calls the following function:
</p>
<pre style="font-size: 12px; line-height: 1.5em; background-color: rgb(255, 229, 204); border: 0px solid rgb(0, 0, 0); margin-left: 0.5em; margin-bottom: 20px; margin-right: 1em; padding: 0.2em 1em; color: black; white-space: pre-wrap; word-wrap: break-word;">void myInputMessageFunction(void *data, const char *message)
{
  userData *udata = (userData *)data;
  csoundInputMessage(udata-&gt;csound, message );
}
</pre>
<p>Now we can call that function to insert Score events into a running csound instance. The formatting of the message should be the same as one would normally have in the Score part of the .csd file. The example shows the format for the message. Note that if you're allowing csound to print its error messages, if you send a malformed message, it will warn you. Good for debugging. There's an example with the csound source code that allows you to type in a message, and then it will send it.
</p>
<p>
</p>
<pre style="font-size: 12px; line-height: 1.5em; background-color: rgb(255, 229, 204); border: 0px solid rgb(0, 0, 0); margin-left: 0.5em; margin-bottom: 20px; margin-right: 1em; padding: 0.2em 1em; color: black; white-space: pre-wrap; word-wrap: break-word;">/*                     instrNum  start  duration   p4   p5   p6  ... pN */
const char *message = "i1        0      1          0.5  0.3  0.1";
myInputMessageFunction((void*)udata, message);
</pre>
<p>
</p>
<p>
  <br />
</p>
<h2><span class="Apple-style-span" style="font-family: Arial,verdana,sans-serif; font-size: 18px; font-weight: bold;">Callbacks</span>
</h2>
<p>Csound can call subroutines declared in the host program when some special events occur. This is done through the callback mechanism. One has to declare to Csound the existence of a callback routine using an API setter function. Then when a corresponding event occurs during performance, Csound will call the host callback routine, eventually passing some arguments to it.
</p>
<p>The example below shows a very simple command line application allowing the user to rewind the score or to abort the performance. This is achieved by reading characters from the keyboard: 'r' for rewind and 'q' for quit. During performance, Csound executes a loop. Each pass in the loop yields ksmps audio frames. Using the API csoundSetYieldCallback function, we can tell to Csound to call our own routine after each pass in its internal loop.
</p>
<p>The yieldCallback routine must be non-blocking. That's why it is a bit tricky to force the C getc function to be non-blocking. To enter a character, you have to type the character and then hit the return key.
  <br />
</p>
<pre style="font-size: 12px; line-height: 1.5em; background-color: rgb(255, 229, 204); border: 0px solid rgb(0, 0, 0); margin-left: 0.5em; margin-bottom: 20px; margin-right: 1em; padding: 0.2em 1em; color: black; white-space: pre-wrap; word-wrap: break-word;">#include &lt;csound/csound.h&gt;

int yieldCallback(CSOUND *csound)
{
  int fd, oldstat, dummy;
  char ch;

  fd = fileno(stdin);
  oldstat = fcntl(fd, F_GETFL, dummy);
  fcntl(fd, F_SETFL, oldstat | O_NDELAY);
  ch = getc(stdin);
  fcntl(fd, F_SETFL, oldstat);
  if (ch == -1)
    return 1;
  switch (ch) {
  case 'r':
    csoundRewindScore(csound);
    break;
  case 'q':
    csoundStop(csound);
    break;
  }
  return 1;
}

int main(int argc, char **argv)
{
  CSOUND *csound = csoundCreate(NULL);
  csoundSetYieldCallback(csound, yieldCallback);
  int result = csoundCompile(csound, argc, argv);
  if (result == 0) {
    result = csoundPerform(csound);
  }
  csoundDestroy(csound);
  return (result &gt;= 0 ? 0 : result);
}</pre>
<p>
</p>
<p>The user can also set callback routines for file open events, real-time audio events, real-time MIDI events, message events, keyboards events, graph events,&nbsp; and channel invalue and outvalue events.
  <br />
</p>
<h2>CsoundPerformanceThread: a Swiss Knife for the API
</h2>
<p>Beside the API, Csound provides a helper C++ class to facilitate threading issues: CsoundPerformanceThread. This class performs a score in a separate thread, allowing the host program to do its own processing in its main thread during the score performance. The host program will communicate with the CsoundPerformanceThread class by sending messages to it, calling CsoundPerformanceThread methods. Those messages are queued inside CsoundPerformanceThread and are treated in a first in first out (FIFO) manner.
</p>
<p>The example below is equivalent to the example in the callback section. But this time, as the characters are read in a different thread, there is no need to have a non-blocking character reading routine.
  <br />
</p>
<pre style="font-size: 12px; line-height: 1.5em; background-color: rgb(255, 229, 204); border: 0px solid rgb(0, 0, 0); margin-left: 0.5em; margin-bottom: 20px; margin-right: 1em; padding: 0.2em 1em; color: black; white-space: pre-wrap; word-wrap: break-word;">#include &lt;csound/csound.hpp&gt;
#include &lt;csound/csPerfThread.hpp&gt;

#include &lt;iostream&gt;
using namespace std;

int main(int argc, char **argv)
{
  Csound *cs = new Csound();
  int result = cs-&gt;Compile(argc, argv);
  if (result == 0) {
    CsoundPerformanceThread *pt = new CsoundPerformanceThread(cs);
    pt-&gt;Play();
    while (pt-&gt;GetStatus() == 0) {
      char c = cin.get();
      switch (c) {
      case 'r':
        cs-&gt;RewindScore();
        break;
      case 'q':
        pt-&gt;Stop();
        pt-&gt;Join();
        break;
      }
    }
  }
  return (result &gt;= 0 ? 0 : result);
}
</pre>
<p>Because CsoundPerformanceThread is not part of the API, we have to link to libcsnd to get it working:
  <br />
</p>
<pre>g++ -DUSE_DOUBLE -o threadPerf threadPerf.cpp -lcsound64 -lcsnd
</pre>
<p>When using this class from Python or Java, this is not an issue because the csnd.py module and the csnd.jar package include the API functions and classes, and the CsoundPerformanceThread class as well.
</p>
<p>Here is a more complete example which could be the base of a frontal application to run Csound. The host application is modeled through the CsoundSession class which has its own event loop (mainLoop). CsoundSession inherits from the API Csound class and it embeds an object of type CsoundPerformanceThread. Most of the CsoundPerformanceThread class methods are used.
</p>
<pre style="font-size: 12px; line-height: 1.5em; background-color: rgb(255, 229, 204); border: 0px solid rgb(0, 0, 0); margin-left: 0.5em; margin-bottom: 20px; margin-right: 1em; padding: 0.2em 1em; color: black; white-space: pre-wrap; word-wrap: break-word;">#include &lt;csound/csound.hpp&gt;
#include &lt;csound/csPerfThread.hpp&gt;

#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class CsoundSession : public Csound
{
public:
  CsoundSession(string const &amp;csdFileName = "") : Csound() {
    m_pt = NULL;
    m_csd = "";
    if (!csdFileName.empty()) {
      m_csd = csdFileName;
      startThread();
    }
  };

  void startThread() {
    if (Compile((char *)m_csd.c_str()) == 0 ) {
      m_pt = new CsoundPerformanceThread(this);
      m_pt-&gt;Play();
    }
  };

  void resetSession(string const &amp;csdFileName) {
    if (!csdFileName.empty())
      m_csd = csdFileName;
    if (!m_csd.empty()) {
      stopPerformance();
      startThread();
    }
  };

  void stopPerformance() {
    if (m_pt) {
      if (m_pt-&gt;GetStatus() == 0)
        m_pt-&gt;Stop();
      m_pt-&gt;Join();
      m_pt = NULL;
    }
    Reset();
  };

  void mainLoop() {
    string s;
    bool loop = true;
    while (loop) {
      cout &lt;&lt; endl &lt;&lt; "l)oad csd; e(vent; r(ewind; t(oggle pause; s(top; p(lay; q(uit: ";
      char c = cin.get();
      switch (c) {
      case 'l':
        cout &lt;&lt; "Enter the name of csd file:";
        cin &gt;&gt; s;
        resetSession(s);
        break;
      case 'e':
        cout &lt;&lt; "Enter a score event:";
        cin.ignore(1000, '\n'); //a bit tricky, but well, this is C++!
        getline(cin, s);
        m_pt-&gt;InputMessage(s.c_str());
        break;
      case 'r':
        RewindScore();
        break;
      case 't':
        if (m_pt)
          m_pt-&gt;TogglePause();
        break;
      case 's':
        stopPerformance();
        break;
      case 'p':
        resetSession("");
        break;
      case 'q':
        if (m_pt) {
          m_pt-&gt;Stop();
          m_pt-&gt;Join();
        }
        loop = false;
        break;
      }
      cout &lt;&lt; endl;
    }
  };

private:
  string m_csd;
  CsoundPerformanceThread *m_pt;
};

int main(int argc, char **argv)
{
  string csdName = "";
  if (argc &gt; 1)
    csdName = argv[1];
  CsoundSession *session = new CsoundSession(csdName);
  session-&gt;mainLoop();
}
</pre>
<p>There are also methods in CsoundPerformanceThread for sending score events (ScoreEvent), for moving the time pointer (SetScoreOffsetSeconds), for setting a callback function (SetProcessCallback) to be called at the end of each pass in the process loop, and for flushing the message queue (FlushMessageQueue).
</p>
<p>As an exercise, the user should complete this example using the methods above and then try to rewrite the example in Python and/or in Java.
  <br />
</p>
<h2>Csound6
</h2>
<p>With Csound6, the API changed a lot, breaking backward compatibility.
</p>
<p> The Python module for the API is called now csnd6 instead of csnd and the corresponding Java package is called now csnd6.jar instead of csnd.jar. To use the CsoundPerformanceThread class from C++, one have to link to libcsnd6 instead of libcsnd.
  <br />
</p>
<p> As usual the best source of information is the csound.h header file. Comparing the Csound6 version of this file with the Csound5 version we see that it has been highly refactored, that many new functions have been added and that some functions have been renamed, or got new signatures, or have been removed.
</p>
<p>Let us review this by sections:
  <br />
</p>
<h3>Instantiation
</h3>
<p><em>csoundInitialize()</em> has a new signature: <em>(int flags)</em> instead of <em>(int *argc, char ***argv, int flags)</em>. The first two arguments were never used. The flags argument can be a bitwise or of the two values CSOUNDINIT_NO_SIGNAL_HANDLER and CSOUNDINIT_NO_ATEXIT. With the first value, Csound will react to an operating system interrupt signal in a custom way instead of the classical "Csound tidy up". The second value is for Windows systems only and tells Csound to destroy all instances when exiting. <em>csoundCreate()</em> calls <em>csoundInitialize()</em> with no flags. So if none of the above options are needed, <em>csoundCreate()</em> is enough to create an instance of Csound.
</p>
<p><em>csoundPreCompile()</em> has been removed.
</p>
<h3>Performance
</h3>
<p>Seven new functions:
</p>
<p>
</p> <em> </em>
<table style="width: 100%; border: 0px dotted rgb(0, 0, 0); border-collapse: collapse;" align="left" cellpadding="0"><tbody>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>TREE *csoundParseOrc(CSOUND *csound, const char *str)</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>int csoundCompileTree(CSOUND *csound, TREE *root)</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundDeleteTree(CSOUND *csound, TREE *tree)</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>int csoundCompileOrc(CSOUND *csound, const char *str)</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>MYFLT csoundEvalCode(CSOUND *csound, const char *str)</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>int csoundCompileArgs(CSOUND *, int argc, char **argv)</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>int csoundStart(CSOUND *csound)</em></td>
  </tr></tbody>
</table><em> </em>
<br />
<p>
</p>
<p>
  <br />
</p>
<p>
  <br />
</p>
<p>&nbsp;
</p>
<p><em>csoundCompileFromStrings()</em> has been removed.
</p>
<p>
  <br />
</p>
<h3>Score Handling
  <br />
</h3>
<p>One new function:<em> int csoundReadScore(CSOUND *csound, char *str)</em>
</p>
<p>
  <br />
</p>
<h3>Attributes
</h3>
<p> Five new configuration/parameter getting and setting functions:
</p>
<p>
</p>
<table style="width: 100%; border: 0px dotted rgb(0, 0, 0); border-collapse: collapse;" align="left" cellpadding="0"><tbody>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>uint32_t csoundGetNchnlsInput(CSOUND *csound)</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>int64_t csoundGetCurrentTimeSamples(CSOUND *csound)</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>int csoundSetOption(CSOUND *csound, char *option)</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundSetParams(CSOUND *csound, CSOUND_PARAMS *p)</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundGetParams(CSOUND *csound, CSOUND_PARAMS *p)</em></td>
  </tr></tbody>
</table>
<br />
<p>
</p>
<p>&nbsp;
  <br />
</p>
<h3>General Input/Ouput
</h3>
<p>Seven new getting and setting functions for managing audio and/or midi input and output device names:
  <br />
</p>
<p>
</p>
<table style="width: 100%; border: 0px dotted rgb(0, 0, 0); border-collapse: collapse;" align="left" cellpadding="0"><tbody>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>const char *csoundGetOutputName(CSOUND *)</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundSetOutput(CSOUND *csound, char *name, char *type, char *format)</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundSetInput(CSOUND *csound, char *name)</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundSetMIDIInput(CSOUND *csound, char *name)</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundSetMIDIFileInput(CSOUND *csound, char *name)</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundSetMIDIOutput(CSOUND *csound, char *name)</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundSetMIDIFileOutput(CSOUND *csound, char *name)</em></td>
  </tr></tbody>
</table>
<p>&nbsp;
</p>
<p>Here is a C++ example illustrating the new API functions presented in the above sections:
  <br />
</p>
<pre style="font-size: 12px; line-height: 1.5em; background-color: rgb(255, 229, 204); border: 0px solid rgb(0, 0, 0); margin-left: 0.5em; margin-bottom: 20px; margin-right: 1em; padding: 0.2em 1em; color: black; white-space: pre-wrap; word-wrap: break-word;">#include &lt;csound/csound.hpp&gt;
#include &lt;csound/csPerfThread.hpp&gt;

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

string orc1 =
"instr 1              \n"
"idur = p3            \n"
"iamp = p4            \n"
"ipch = cpspch(p5)    \n"
"kenv linen  iamp, 0.05, idur, 0.1 \n"
"a1   poscil kenv, ipch \n"
"     out    a1         \n"
"endin";

string orc2 =
"instr 1    \n"
"idur = p3  \n"
"iamp = p4  \n"
"ipch = cpspch(p5)  \n"
"a1 foscili iamp, ipch, 1, 1.5, 1.25  \n"
"   out     a1      \n"
"endin\n";

string orc3 =
"instr 1    \n"
"idur = p3  \n"
"iamp = p4  \n"
"ipch = cpspch(p5-1)         \n"
"kenv  linen    iamp, 0.05, idur, 0.1  \n"
"asig  rand     0.45         \n"
"afilt moogvcf2 asig, ipch*4, ipch/(ipch * 1.085)  \n"
"asig  balance  afilt, asig  \n"
"      out      kenv*asig    \n"
"endin\n";

string sco1 =
"i 1 0 1    0.5 8.00\n"
"i 1 + 1    0.5 8.04\n"
"i 1 + 1.5  0.5 8.07\n"
"i 1 + 0.25 0.5 8.09\n"
"i 1 + 0.25 0.5 8.11\n"
"i 1 + 0.5  0.8 9.00\n";

string sco2 =
"i 1 0 1    0.5 9.00\n"
"i 1 + 1    0.5 8.07\n"
"i 1 + 1    0.5 8.04\n"
"i 1 + 1    0.5 8.02\n"
"i 1 + 1    0.5 8.00\n";

string sco3 =
"i 1 0 0.5  0.5 8.00\n"
"i 1 + 0.5  0.5 8.04\n"
"i 1 + 0.5  0.5 8.00\n"
"i 1 + 0.5  0.5 8.04\n"
"i 1 + 0.5  0.5 8.00\n"
"i 1 + 0.5  0.5 8.04\n"
"i 1 + 1.0  0.8 8.00\n";

void noMessageCallback(CSOUND* cs, int attr, const char *format, va_list valist)
{
  // Do nothing so that Csound will not print any message,
  // leaving a clean console for our app
  return;
}

class CsoundSession : public Csound
{
public:
  CsoundSession(vector&lt;string&gt; &amp; orc, vector&lt;string&gt; &amp; sco) : Csound() {
    m_orc = orc;
    m_sco = sco;
    m_pt = NULL;
  };

  void mainLoop() {
    SetMessageCallback(noMessageCallback);
    SetOutput((char *)"dac", NULL, NULL);
    GetParams(&amp;m_csParams);
    m_csParams.sample_rate_override = 48000;
    m_csParams.control_rate_override = 480;
    m_csParams.e0dbfs_override = 1.0;
    // Note that setParams is called before first compilation
    SetParams(&amp;m_csParams);
    if (CompileOrc(orc1.c_str()) == 0) {
      Start(this-&gt;GetCsound());
      // Just to be sure...
      cout &lt;&lt; GetSr() &lt;&lt; ", " &lt;&lt; GetKr() &lt;&lt; ", ";
      cout &lt;&lt; GetNchnls() &lt;&lt; ", " &lt;&lt; Get0dBFS() &lt;&lt; endl;
      m_pt = new CsoundPerformanceThread(this);
      m_pt-&gt;Play();
    }
    else {
      return;
    }

    string s;
    TREE *tree;
    bool loop = true;
    while (loop) {
      cout &lt;&lt; endl &lt;&lt; "1) 2) 3): orchestras, 4) 5) 6): scores; q(uit: ";
      char c = cin.get();
      cin.ignore(1, '\n');
      switch (c) {
      case '1':
        tree = ParseOrc(m_orc[0].c_str());
        CompileTree(tree);
        DeleteTree(tree);
        break;
      case '2':
        CompileOrc(m_orc[1].c_str());
        break;
      case '3':
        EvalCode(m_orc[2].c_str());
        break;
      case '4':
        ReadScore((char *)m_sco[0].c_str());
        break;
      case '5':
        ReadScore((char *)m_sco[1].c_str());
        break;
      case '6':
        ReadScore((char *)m_sco[2].c_str());
        break;
      case 'q':
        if (m_pt) {
          m_pt-&gt;Stop();
          m_pt-&gt;Join();
        }
        loop = false;
        break;
      }
    }
  };

private:
  CsoundPerformanceThread *m_pt;
  CSOUND_PARAMS m_csParams;
  vector&lt;string&gt; m_orc;
  vector&lt;string&gt; m_sco;
};

int main(int argc, char **argv)
{
  vector&lt;string&gt; orc;
  orc.push_back(orc1);
  orc.push_back(orc2);
  orc.push_back(orc3);
  vector&lt;string&gt; sco;
  sco.push_back(sco1);
  sco.push_back(sco2);
  sco.push_back(sco3);
  CsoundSession *session = new CsoundSession(orc, sco);
  session-&gt;mainLoop();
}
</pre>
<p>&nbsp;&nbsp;
  <br />
</p>
<p>
</p>
<h3>Realtime Audio I/O
</h3>
<p>Four new functions for dealing with realtime audio modules:
  <br />
</p>
<p>
</p>
<table style="width: 100%; border: 0px dotted rgb(0, 0, 0); border-collapse: collapse;" align="left" cellpadding="0"><tbody>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundSetRTAudioModule(CSOUND *csound, char *module)</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>int csoundGetModule(CSOUND *csound, int number, char **name, char **type)</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>int csoundGetAudioDevList(CSOUND *csound, CS_AUDIODEVICE *list, int isOutput)</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundSetAudioDeviceListCallback(CSOUND *csound,</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>int (*audiodevlist__)(CSOUND *, CS_AUDIODEVICE *list, int isOutput))</em>
    <br /></td>
  </tr></tbody>
</table>
<br />&nbsp;
<p>
</p>
<h3>Realtime Midi I/O
</h3>
<p>Four new functions for dealing with realtime Midi modules:&nbsp;
  <br />
</p>
<p>
</p>
<table style="width: 100%; border: 0px dotted rgb(0, 0, 0); border-collapse: collapse;" align="left" cellpadding="0"><tbody>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundSetMIDIModule(CSOUND *csound, char *module)</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundSetHostImplementedMIDIIO(CSOUND *csound, int state)</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>int csoundGetMIDIDevList(CSOUND *csound, CS_MIDIDEVICE *list, int isOutput)</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundSetMIDIDeviceListCallback(CSOUND *csound,</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>int (*mididevlist__)(CSOUND *, CS_MIDIDEVICE *list, int isOutput))</em>
    <br /></td>
  </tr></tbody>
</table>
<br />
<p>
</p>
<br />
<p>&nbsp;
</p>
<h3>Message and Text
</h3>
<p>One new message function:
  <br />
</p>
<p>
</p>
<table style="width: 100%; border: 0px dotted rgb(0, 0, 0); border-collapse: collapse;" align="left" cellpadding="0"><tbody>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundSetDefaultMessageCallback(</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp; <em>void (*csoundMessageCallback_)(CSOUND *, int attr,</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>const char *format,</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>va_list valist))</em>
    <br /></td>
  </tr></tbody>
</table>
<br />
<p>
</p>
<p>
  <br />
</p>
<p>&nbsp;
</p>
<p><em>void csoundCreateMessageBuffer(CSOUND *csound, int toStdOut)</em> replaces <em>csoundEnableMessageBuffer()</em>.
</p>
<p>
  <br />
</p>
<h3>Channels, Control and Events
</h3>
<p>Historically there were several ways of sending data to and from Csound through software buses:
</p>
<ul>
  <li>numbered channels with no callback (opcodes <em>chani</em> and <em>chano</em> with API functions <em>csoundChanOKGet()</em>, etc)</li>
  <li>named channels with no callback (opcodes <em>chnget</em> and <em>chnset</em> with API&nbsp; function <em>csoundGetChannelPtr()</em>)</li>
  <li>named channels with callback (opcodes <em>chnrecv</em> and <em>chnsend</em>) with API function <em>csoundSetChannelIOCallback()</em>)
  <br /></li>
  <li>named channels with callback (opcodes <em>invalue</em> and <em>outvalue</em> with API&nbsp; functions <em>csoundSetOutputValueCallback()</em>, etc)</li>
</ul>
<p>A bit confusing!
</p>
<p>This has been simplified in two categories:
</p>
<h4> Named Channels with no Callback
</h4>
<p>This category uses <em>csoundGetChannelPtr()</em> as in Csound5 to get a pointer to the data of the named channel. There are also six new functions to send data to and from a named channel in a thread safe way:
</p>
<p>
</p>
<table style="width: 100%; border: 0px dotted rgb(0, 0, 0); border-collapse: collapse;" align="left" cellpadding="0"><tbody>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>MYFLT csoundGetControlChannel(CSOUND *csound, const char *name, int *err)</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundSetControlChannel(CSOUND *csound, const char *name, MYFLT val)</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundGetAudioChannel(CSOUND *csound, const char *name, MYFLT *samples)</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundSetAudioChannel(CSOUND *csound, const char *name, MYFLT *samples)</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundGetStringChannel(CSOUND *csound, const char *name, char *string)</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundSetStringChannel(CSOUND *csound, const char *name, char *string)</em>
    <br /></td>
  </tr></tbody>
</table>
<p>&nbsp;
</p>
<p>
</p>
<p>The opcodes concerned are <em>chani</em>, <em>chano</em>, <em>chnget</em> and <em>chnset</em>. When using numbered channels with <em>chani</em> and <em>chano</em>, the API sees those channels as named channels, the name being derived from the channel number (i.e. 1 gives "1", 17 gives "17", etc).
  <br />
</p>
<p>There is also a new helper function returning the data size of a named channel:
</p>
<p><em>int csoundGetChannelDatasize(CSOUND *csound, const char *name)</em>
</p>
<p>It is particularly useful when dealing with string channels.
</p>
<p>The following functions have been removed: <em>csoundChanIKSet()</em>, <em>csoundChanOKGet()</em>, <em>csoundChanIASet()</em>, <em>csoundChanOAGet()</em>, <em>csoundChanIKSetValue()</em>, <em>csoundChanOKGetValue()</em>, <em>csoundChanIASetSample()</em>, and&nbsp; <em>csoundChanOAGetSample()</em>.
</p>
<h4> Named Channels with Callback
</h4>
<p>Each time a named channel with callback is used (opcodes <em>invalue</em>, <em>outvalue</em>, <em>chnrecv</em>, and <em>chnsend</em>), the corresponding callback registered by one of those functions will be called:
</p>
<p>
</p>
<table style="width: 100%; border: 0px dotted rgb(0, 0, 0); border-collapse: collapse;" align="left" cellpadding="0"><tbody>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundSetInputChannelCallback(CSOUND *csound,</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; <em>channelCallback_t inputChannelCalback)</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundSetOutputChannelCallback(CSOUND *csound,</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>channelCallback_t outputChannelCalback)</em>
    <br /></td>
  </tr></tbody>
</table>
<br />
<p>
</p>
<p>&nbsp;
</p>
<p>These functions replace <em>csoundSetInputValueCallback()</em> and <em>csoundSetOutputValueCallback()</em>, which are still in the header file but are now deprecated.
</p>
<h4>Other Channel Functions
</h4>
<p>
</p>
<table style="width: 100%; border: 0px dotted rgb(0, 0, 0); border-collapse: collapse;" align="left" cellpadding="0"><tbody>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>int csoundSetPvsChannel(CSOUND *, const PVSDATEXT *fin, const char *name)</em>, and
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>int csoundGetPvsChannel(CSOUND *csound, PVSDATEXT *fout, const char *name)</em>
    <br /></td>
  </tr></tbody>
</table>
<p>
  <br />replace <em>csoundPvsinSet()</em> and <em>csoundPvsoutGet()</em>.
</p>
<p>
</p>
<table style="width: 100%; border: 0px dotted rgb(0, 0, 0); border-collapse: collapse;" align="left" cellpadding="0"><tbody>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>int csoundSetControlChannelHints(CSOUND *, const char *name,</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>controlChannelHints_t hints)</em>, and
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>int csoundGetControlChannelHints(CSOUND *, const char *name,</em></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>controlChannelHints_t *hints)</em>
    <br /></td>
  </tr></tbody>
</table>
<p>replace csoundSetControlChannelParams() and csoundGetControlChannelParams().
</p>
<p>
</p>
<p><em>int *csoundGetChannelLock(CSOUND *, const char *name)</em> has a new signature: the third argument has been removed.
</p>
<p>
</p>
<table style="width: 100%; border: 0px dotted rgb(0, 0, 0); border-collapse: collapse;" align="left" cellpadding="0"><tbody>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);">int csoundKillInstance(CSOUND *csound, MYFLT instr,
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>char *instrName, int mode, int allow_release)</em>
    <br /></td>
  </tr></tbody>
</table>
<p>kills off one or more running instances of an instrument.
</p>
<p>
</p>
<table style="width: 100%; border: 0px dotted rgb(0, 0, 0); border-collapse: collapse;" align="left" cellpadding="0"><tbody>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>int csoundRegisterKeyboardCallback(CSOUND *,</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <em>int (*func)(void *userData, void *p, unsigned int type),</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>void *userData, unsigned int type)</em>, and
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundRemoveKeyboardCallback(CSOUND *csound,</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>int (*func)(void *, void *, unsigned int))</em>
    <br /></td>
  </tr></tbody>
</table>replace <em>csoundSetCallback()</em> and <em>csoundRemoveCallback()</em>.
<br />
<p>
</p>
<h3>Tables
</h3>
<p>Two new functions to copy data from a table to a host array, or from a host array to a table in a thread safe way:
</p>
<p>
</p>
<table style="width: 100%; border: 0px dotted rgb(0, 0, 0); border-collapse: collapse;" align="left" cellpadding="0"><tbody>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundTableCopyOut(CSOUND *csound, int table, MYFLT *dest)</em>, and
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundTableCopyIn(CSOUND *csound, int table, MYFLT *src)</em>
    <br /></td>
  </tr></tbody>
</table>&nbsp;
<p>
</p>
<h3>Miscellaneous Functions
</h3>
<p>One can now create a circular buffer with elements of any type. Thus the existing functions <em>csoundCreateCircularBuffer()</em>, <em>csoundReadCircularBuffer()</em>, and <em>csoundWriteCircularBuffer()</em> have a new signature:
</p>
<p>
</p>
<table style="width: 100%; border: 0px dotted rgb(0, 0, 0); border-collapse: collapse;" align="left" cellpadding="0"><tbody>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void *csoundCreateCircularBuffer(CSOUND *csound, int numelem, int elemsize)</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>int csoundReadCircularBuffer(CSOUND *csound, void *circular_buffer,</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>void *out, int items)</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>int csoundWriteCircularBuffer(CSOUND *csound, void *p,</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>const void *inp, int items)</em>
    <br /></td>
  </tr></tbody>
</table>&nbsp;
<p>
</p>
<p>There are also two new functions:
</p>
<p>
</p>
<table style="width: 100%; border: 0px dotted rgb(0, 0, 0); border-collapse: collapse;" align="left" cellpadding="0"><tbody>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>int csoundPeekCircularBuffer(CSOUND *csound, void *circular_buffer,</em>
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>void *out, int items)</em>, and
    <br /></td>
  </tr>
  <tr>
    <td style="border: 0px dotted rgb(0, 0, 0);"><em>void csoundFlushCircularBuffer(CSOUND *csound, void *p)</em>
    <br /></td>
  </tr></tbody>
</table>&nbsp;
<p>
</p>
<p>The function <em>void csoundDestroyCircularBuffer(CSOUND *csound, void *circularbuffer)</em> replaces <em>csoundFreeCircularBuffer()</em>.
</p>
<p>Finally the new function <em>CSOUND *csoundGetInstance(long obj)</em> is reserved for the Swig generated Python wrapper.
</p>
<h3>Deprecated and Removed Functions
</h3>
<p><em>csoundQueryInterface()</em>, <em>csoundSetChannelIOCallback()</em>, and <em>csoundPerformKsmpsAbsolute()</em> are deprecated.
</p>
<p><em>csoundGetStrVarMaxLen()</em>, <em>csoundGetSampleFormat()</em>, <em>csoundGetSampleSize()</em>, <em>csoundGetOutputFileName()</em>, <em>csoundSetMakeXYinCallback()</em>, <em>csoundSetReadXYinCallback()</em>, <em>csoundSetKillXYinCallback()</em>, and <em>csoundLocalizeString()</em> have been removed.
  <br />
</p>
<p>
</p>
<p>&nbsp;
</p>
<p>&nbsp;
</p>
<h2>References &amp; Links
  <br />
</h2>
<p>Michael Gogins 2006, "Csound and CsoundVST API Reference Manual", http://csound.sourceforge.net/refman.pdf
</p>
<p>Rory Walsh 2006, "Developing standalone applications using the Csound Host API and wxWidgets", Csound Journal Volume 1 Issue 4 - Summer 2006, http://www.csounds.com/journal/2006summer/wxCsound.html
</p>
<p>Rory Walsh 2010, "Developing Audio Software with the Csound Host API",&nbsp; The Audio Programming Book, DVD Chapter 35, The MIT Press
  <br />
</p>
<p>François Pinot 2011, "Real-time Coding Using the Python API: Score Events", Csound Journal Issue 14 - Winter 2011, http://www.csounds.com/journal/issue14/realtimeCsoundPython.html
  <br />
</p>
<p>
</p>
<p>
</p>
   <hr/>
    <a href="/csound/_edit/">EDIT</a>

</div>

<script type="text/javascript">
jQuery(function ($) {
    $('#bookcontent').annotator()
   		.annotator('setupPlugins', {}, {
                Tags: false,
                Filter: {
                  addAnnotationFilter: false
                },
                Permissions: false,
                AnnotateItPermissions: {}
              });
});
</script>



</div>
<!-- End of content -->

</div>  
<!-- DEV TOOLS -->
<div id="bookidebug">
</div>

<!-- sputnik error page -->
<div id="dialog-sputnik-qrac" style="display: none"></div>
</body>
</html>

